### Содержание:
- [Что такое процесс](https://github.com/blinky-z/ThreadsLearn#1-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Что такое поток?](https://github.com/blinky-z/ThreadsLearn#2-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Почему нужно много потоков внутри одного процесса?](https://github.com/blinky-z/ThreadsLearn#3-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)
- [Отличие процесса от потока](https://github.com/blinky-z/ThreadsLearn#4-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%BE%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
- [Состояния потоков](https://github.com/blinky-z/ThreadsLearn#5-%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Почему создание и уничтожение процессов дороже, чем потоков?](https://github.com/blinky-z/ThreadsLearn#6-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%B4%D0%BE%D1%80%D0%BE%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Зачем нужна многозадачность](https://github.com/blinky-z/ThreadsLearn#7-%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Как происходит процесс смены потоков (context switch)?](https://github.com/blinky-z/ThreadsLearn#8-%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%BC%D0%B5%D0%BD%D1%8B-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-context-switch)
- [Реализации потоков на уровне ядра и уровне пользователя](https://github.com/blinky-z/ThreadsLearn#9-%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне пользователя](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне ядра](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0)

### 1) Что такое процесс? чем владеет процесс? своими словами
Процесс - это абстракция, реализованная на программном уровне (то есть не какая-то аппаратная штука).
Процесс был придуман для организации всех данных, необходимых для работы программы). Можно сказать, что это просто контейнер,
в котором находятся ресурсы программы. Ресурсы - это адресное пространство, потоки, открытые файлы, дочерние процессы.

Просто к слову, адресное пространство - это не только пространство в оперативной памяти (начало адресов и конец), но также может
иногда использоваться и виртуальная память. Адресное пространство - это абстрактная вещь, через которую программа может получать
доступ к памяти например так: memory[0], не зная к какой памяти вообще обращается, а доступ к оперативной или виртуальной памяти
обеспечивают другие вещи.
### 2) Что такое поток? чем владеет поток? своими словами?
 Поток - это сущность, в которой выполняются программы. Поток легче, чем процесс, и их создание стоит дешевле.
Поток содержит такие ресурсы, как счётчик команд, регистры и стек. Потоки внутри одного процесса используют адресное пространство
процесса, то есть у них общее пространство. То есть, поток нужен именно для выполнения программы.

### 3) Почему нужно много потоков внутри одного процесса?
Потоки нужны потому, что в программах могут выполняться много задач, также они могут в какие-то
моменты времени простаивать в ожидании какого-либо результата (я сейчас просто говорю абстрактно будто бы это просто задачи,
а не потоки и процессы). Конечно, можно было бы создавать ещё один процесс под задачу, но:
  - у процесса будет отдельное адресное пространство и совсем другие данные, тогда как задачи обычно обмениваются данными и
  должны использовать общие данные или результаты других задач. Поэтому, нужен способ обращаться к общим данным
  - по вопросам производительности: создание и уничтожение процесса дороже, чем создание потока.
### 4) отличие процесса от потока?
Процесс описывает выполняющуюся программу (описывает, значит содержит необходимые ресурсы для работы программы), а сама программа же, её
процедуры, выполняются в потоках. Главное надо понимать, что программа - это не один поток.

**Программа** - это *набор взаимодейстущих между собой потоков*, и может быть, даже процессов.

Конечно, может быть 1 поток, если это какая-то совсем простая программа.
А в самых простейших операционных системах процесс имеет только единственный поток выполнения, поэтому в таких случаях немного размываются
границы между потоками и процессами, т.к. 1 процесс - это 1 поток, но это так, к слову.

 **Вывод:** процесс - это всего лишь способ сгруппировать взаимосвязанные данные, ресурсы, а вот потоки - уже именно то, что
распределяется и выполняется на процессоре. А если кто-то говорит о том, что процессы сменяются и выделяется время процессам,
наверное, имеется в виду процесс с единственным потоком в простых ОСях, так как процессы сменяться не могут, сменяются и
выполняются на процессоре только потоки. Context switch тоже относится только к потокам.
### 5) Состояния потоков
- Выполняемый
- Готовый (процесс не заблокирован, и может выполняться, однако, в данный момент времени на процессоре выполняется другой поток. Когда
происходит смена потоков, то новым выполняемым потоком становится только один из готовых потоков).
- Заблокированный (обычно ожидает результатов завершения блокирующей операции)

### 6) Почему создание и уничтожение процессов дороже, чем потоков?
Процесс - полностью описывает программу: адресное пространство, потоки, открытые файлы, дочерние процессы, все эти таблицы данных
должны инициализироваться. Тогда как потоки не хранят таких данных (т.к. они используют данные процесса, к которому они прикреплены), а
хранит только счетчик команд, стек и регистры (поэтому потоки называют также "легкими процессами").
### 7) Зачем нужна многозадачность
Многозадачность нужна для того, чтобы на процессоре могли выполняться стразу несколько потоков.
Данная необходимость возникла потому, что не очень хочется пустой траты процессорного времени, то есть простаивания процессора.
Простаивание возникает тогда, когда какой-либо поток блокируется в ожидании результата блокирующей операции. Тогда, лучше отдать
процессорное время другому потоку, чтобы процессор не простаивал, таким образом повышая производительность.
### 8) Как происходит процесс смены потоков (context switch)?
Когда поток блокируется, происходит прерывание (это что-то типо
системного вызова), и все необходимые данные помещаются в стек аппаратными средствами, и происходит обработка прерывания уже
программными средствами - обработчиками конкретных прерываний (обычно, это процедуры на языке C). Типы прерываний бывают разными, в данном же
случае будет тип смены потока и будет вызван обработчик прерывания context switch'а. Данный обработчик вызывает планировщик, и далее вся работа
по распределению времени процессов ложится на него.

Вызывать сразу планировщик нельзя, т.к. требуется работа аппаратных ресурсов, а также выполнение ассемблерного кода для перемещения данных в стек.
### 9) Реализации потоков на уровне ядра и уровне пользователя
#### Потоки на уровне пользователя
В данной реализации потоки реализованы на пользовательском уровне, а значит, ядру ничего ни о каких потоках не известно. Ядро работает с потоками
как с однопоточными процессами. Потоки запускаются поверх *системы поддержки исполнения программ* (run-time system), которая управляет потоками.
Run-time система находится внутри процесса.
Также, так как ядру ничего неизвестно о потоках и нет данных о них, процессам придется хранить *таблицу потоков* (аналогична с таблицей процессов),
чтобы отслеживать потоки, которые выполняются внутри процесса. В таблице потоков хранится такая информация о потоках, как: указатель стека, регистр,
состояние потока и прочее (все, что нужно для работы потоков, опять же аналогия с процессами).

**Достоинства:**
- Потоки могут быть реализованы на ОСях (как библиотеки), которые даже не поддерживают потоки (а только процессы).
 Но вряд ли сейчас это актуально вообще
- Переключение потоков происходит быстрее, так как нет необходимости переключения в режим ядра. Все данные уже есть на стороне пользователя:
    1) Сохранение данных в стек тоже не требуется, данные могут быть сохранены в таблицу потоков (стек находится в таблице потоков,
    а не в ядре)
    2) Сохранение данных и вызов планировщика - это локальные процедуры и могут быть вызваны сразу с пользовательского уровня. Как итог,
    переключения в режим ядра вообще не происходит.
- Система поддержки исполнения программ владеет информацией о том, чем занимаются все потоки процесса, поэтому может лучше управлять работой
потоков и временем работы каждого потока. Ядро такой информацией не обладает (данная проблема может решиться использованием приоритетов, но это
универсальное решение, а в run-time система может быть какая-то другая, специфическая информация, поэтому тут выигрывают потоки на стороне
пользователя)

**Недостатки:**
- При выполнении блокирующего вызова в одном потоке, блокируются все потоки данного процесса, ведь ядро думает, что работает с одним процессом,
и приписывает этому процессу единое состояние выполнения: блокируется 1 поток (как думает ядро) - блокируется весь процесс со всеми потоками (как
происходит на самом деле)
 Как решение проблемы могут использоваться неблокирующие системные вызовы, но нужна их поддержка. Также, может использоваться мультиплексор select.
- Не поддерживается работа аппаратного таймера с пользователскими потоками, соответственно, не возможно будет планирование выделениия квантов
времени потокам, поэтому потокам придется вызывать функции уступания процессорного времени самостоятельно, и только тогда планировщик сможет
планировать работу, иначе поток будет работать бесконечно

#### Потоки на уровне ядра
В данной реализации уже нет необходимости в таблице потоков *в каждом процессе* и нет необходимости в run-time системе. Вместо этого, теперь
аналогичная таблица потоков находится на стороне ядра, где отслеживаются *все потоки* системы.

Однако, теперь, когда нужно создать или уничтожить поток, должны производиться обращения к ядру.

Также, разница заключается в том, что планировщик в run-time системе работал только с потоками внутри *только этого процесса*, пока ядро не
отдавало процессорное время другому процессу (и уже работала другая run-time система только с собственными потоками). Ядро же теперь знает о всех
потоках системы и может отдавать процессорное время как потоку из одного процесса, так и потоку из другого процесса.

**Достоинства**
- Не нужно мучиться с проблемой блокирования всех потоков, в отличие от реализации потоков на пользовательском уровне. Блокируется только один
поток, так как ядро теперь знает о существовании потоков

**Недостатки**
- Создание и уничтожение потоков требует более высоких затрат

### 10) что такое вытесняющая многозадачность?
### 11) что такое кооперативная многозадачность?
### 12) что такое планировщик задач в ОС?
### 13) как примерно работает планировщик задач? на высокром уровне абстракции
### 14) что такое зелёный поток? чем он отличается от обычного потока?
### 15) операционная система (например, linux) решила, что данный процесс должен запустится. Что это вообще означает, и какие операционная система делает действия в этом месте.
### 16) Создать новый процесс дорого, или дешево с точки зрения ресурсов ОС? Почему так? Как вообще создаются процессы? Откуда они изначально берутся
### 17) Создать новый поток дорого, или дешево с точки зрения ресурсов ОС? Почему так? Кто создаёт потоки? Откуда первый поток берётся?
### 18) Есть программа. Она читает из сокета. Если она будет читать из сокета в 10 потоков, она всегда будет быстрее, чем с 1 потоком? Объясни почему так
### 19) Есть программа. Она считает сумму какого-то большого массива данных. Она всегда будет быстрее в 10 потоков, чем если бы в ней был 1 поток? Объясни почему так?
### 20) Есть процесс - музыкальный плеер. Каким образом ты слышишь постоянно музыку, но при этом работают и другие процессы
### 21) Есть операционная система. У неё есть функция - можно задать для процесса какой-то приоритет. Что это такое, как приоритеты работают, и что делать если у всех процессов будет максимальный приоритет
### 22) Что такое примитивы (методы) синхронизации, и как это вообще работает? Если бы ты писал свой язык программирования, в твоем языке могли бы появится примитивы синхронизации?
### 23) Существует много всяких примитивов синронизации. Я - человек, который ничего об этом не знает. Расскажи мне алгоритм, как выбрать какой-то примитив синхронизации для моей задачи. Типо, если мне надо ***, и ***, то я должен выбрать *** потому, что.
### 24) А операции с примитивами синхронизации - они вообще дорогие? Можно что-то сделать, для того чтобы их не пришлось ипользовать, или их использование было минимальным?
### 25) Монитор и мьютекс - это одно и тоже, или нет?