### Содержание:
- [Что такое процесс](https://github.com/blinky-z/ThreadsLearn#1-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Что такое поток?](https://github.com/blinky-z/ThreadsLearn#2-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Почему нужно много потоков внутри одного процесса?](https://github.com/blinky-z/ThreadsLearn#3-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)
- [Отличие процесса от потока](https://github.com/blinky-z/ThreadsLearn#4-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%BE%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
- [Состояния потоков](https://github.com/blinky-z/ThreadsLearn#5-%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Почему создание и уничтожение процессов дороже, чем потоков?](https://github.com/blinky-z/ThreadsLearn#6-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%B4%D0%BE%D1%80%D0%BE%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Зачем нужна многозадачность](https://github.com/blinky-z/ThreadsLearn#7-%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Как происходит процесс смены потоков (context switch)?](https://github.com/blinky-z/ThreadsLearn#8-%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%BC%D0%B5%D0%BD%D1%8B-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-context-switch)
- [Реализации потоков на уровне ядра и уровне пользователя](https://github.com/blinky-z/ThreadsLearn#9-%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне пользователя](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне ядра](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0)

### 1) Что такое процесс
**Процесс** - это абстракция, реализованная на программном уровне (то есть не какая-то аппаратная штука).
Процесс был придуман для организации всех данных, необходимых для работы программы. Можно сказать, что это просто контейнер,
в котором находятся *ресурсы программы*.

**Ресурсы программы:**
- адресное пространство
- потоки 
- открытые файлы
- дочерние процессы

Просто к слову, адресное пространство - это не только пространство в оперативной памяти (начало адресов и конец), но также может
иногда использоваться и виртуальная память. Адресное пространство - это абстрактная вещь, через которую программа может получать
доступ к памяти например так: memory[0], не зная к какой памяти вообще обращается, а доступ к оперативной или виртуальной памяти
обеспечивают другие вещи.

### 2) Что такое поток
 **Поток** - это сущность, в которой выполняются программы. Поток легче, чем процесс, и их создание стоит дешевле.
Поток содержит такие ресурсы, как счётчик команд, регистры и стек. Потоки внутри одного процесса используют адресное пространство
процесса, то есть у них общее пространство. То есть, поток нужен именно для выполнения программы.

### 3) Почему нужно много потоков внутри одного процесса
Потоки нужны потому, что в программах могут выполняться много задач, также они могут в какие-то
моменты времени простаивать в ожидании какого-либо результата (я сейчас просто говорю абстрактно будто бы это просто задачи,
а не потоки и процессы). Конечно, можно было бы создавать ещё один процесс под задачу, но:
  - у процесса будет отдельное адресное пространство и совсем другие данные, тогда как задачи обычно обмениваются данными и
  должны использовать общие данные или результаты других задач. Поэтому, нужен способ обращаться к общим данным
  - по вопросам производительности: создание и уничтожение процесса дороже, чем создание потока.

### 4) Отличие процесса от потока
Процесс описывает выполняющуюся программу (описывает, значит содержит необходимые ресурсы для работы программы), а сама программа же, её
процедуры, выполняются в потоках. Главное надо понимать, что программа - это не один поток.

**Программа** - это *набор взаимодейстущих между собой потоков*, и может быть, даже процессов.

Конечно, может быть 1 поток, если это какая-то совсем простая программа.
А в самых простейших операционных системах процесс имеет только единственный поток выполнения, поэтому в таких случаях немного размываются
границы между потоками и процессами, т.к. 1 процесс - это 1 поток, но это так, к слову.

 **Вывод:** процесс - это всего лишь способ сгруппировать взаимосвязанные данные, ресурсы, а вот потоки - уже именно то, что
распределяется и выполняется на процессоре. А если кто-то говорит о том, что процессы сменяются и выделяется время процессам,
наверное, имеется в виду процесс с единственным потоком в простых ОСях, так как процессы сменяться не могут, сменяются и
выполняются на процессоре только потоки. Context switch тоже относится только к потокам.

### 4) Что такое счётчик команд

**Счётчик команд** - регистр процессора, который указывает, какую команду нужно выполнить следующей. 

После выполнения текущей команды счётчик увеличивается (инкрементируется), и в регистре будет храниться следующая команда, которую необходимо выполнить.

Команда, которая выполняется в текущий момент, хранится в **регистре команд**.

### 5) Состояния потоков
 - *Выполняемый*
 - *Готовый* (процесс не заблокирован, и может выполняться, однако, в данный момент времени на процессоре выполняется другой поток. Когда
происходит смена потоков, то новым выполняемым потоком становится только один из готовых потоков).
 - *Заблокированный* (обычно ожидает результатов завершения блокирующей операции)

### 6) Почему создание и уничтожение процессов дороже, чем потоков
Процесс - полностью описывает программу: адресное пространство, потоки, открытые файлы, дочерние процессы, все эти таблицы данных
должны инициализироваться при создании процесса. Тогда как потоки не хранят таких данных (т.к. они используют данные процесса, к которому они
прикреплены), а хранит только счетчик команд, стек и регистры (поэтому потоки также называют "легкими процессами").

### 7) Что такое многозадачность
**Многозадачность** - свойство ОСи, позволяющее обеспечивать работу сразу нескольких задач на одном процессоре. Многозадачность может быть
**параллельной** (если каждая задача выполняется на отдельном процессоре) или **псевдопараллельной** (если задачи выполняются на одном процессоре).

### 8) Для чего нужна многозадачность
Многозадачность нужна для того, чтобы на процессоре могли выполняться сразу несколько потоков.
Данная необходимость возникла потому, что крайне нежелательная пустая трата процессорного времени, то есть простаивание процессора.
Простаивание возникает тогда, когда какой-либо поток блокируется в ожидании результата блокирующей операции. Тогда, лучше отдать
процессорное время другому потоку, чтобы процессор не простаивал, таким образом повышая производительность.

### 9) Вытесняющая и кооперативная многозадачность
Существуют **вытесняющие** и **кооперативные** алгоритмы планирования:
 - При вытесняющем режиме работы потоки могут **прерываться принудительно** при истечении отведенного им кванта времени.
 - При невытесняющем режиме работы потоки могут **работать столько, сколько им необходимо**. Переключение контекста произойдет **только** при
 завершении работы потока, блокировке или при добровольном предоставлении возможности выполнения. При разработке данного алгоритма нужно
 быть предельно осторожным, иначе может возникнуть ситуация, когда один поток полностью захватит процессор.

**Вывод:** в вытесняющей многозадачности распределением процессорного времени занимается *операционная система*, а в кооперативной - сами *программы*.

### 12) Что такое Context switch
**Context switch (переключение контекста)** - это процесс прерывания работы потока с сохранением состояния потока и загрузка состояния
следующего потока, который будет выполняться на процессоре. В процесс переключения контекста также входит вызов *планировщика*, который решает,
какому следующему потоку отдать процессорное время. Context switch - основа *многозадачности*.

Переключение контекста происходит в следующих ситуациях:
 1) При создании нового потока
 2) При завершении работы потока
 3) При блокировке потока в ожидании результата блокирующей операции (операция ввода-вывода, блокировка на семафоре или мьютексе или другая
причина блокировки)
 4) При возникновении прерывания ввода-вывода
 
### 10) Что такое планировщик задач в ОС
**Планировщик задач** - это программа (демон), на которую ложится задача выбора потока, который будет выполняться следующим. Планировщики
применяются в многозадачности.

### 11) Как работает планировщик задач
**Алгоритм планирования** - алгоритм, который используется в планировщике. От алгоритма планирования зависит распределение порядка работы
потоков.

**Основной принцип планирования** - предоставление каждому потоку **справедливой** доли процессорного времени. Однако, различные категории потоков
могут получать большее процессорное время, чем потоки с низким приоритетом.

Планировщики применяются в различных средах:
 - *Пакетные системы*
 - *Интерактивная система*
 - *Система реального времени*

**Рассмотрим работу планировщика в ситуациях переключения контекста:**
#### Создание нового потока
Планировщик должен решить, какому потоку позволить выполняться следующим: дочерний (только что созданный) или родительский (инициировавший
создание нового потока)
#### Завершение работы потока
Когда поток завершает свою работу, необходимо выбрать следующий поток для выполнения
#### Блокировка потока
Когда поток блокируется, планировщик должен выбрать поток, который будет выполняться следующим во избежании пустой траты процессорного времени
#### Возникновение прерывания ввода-вывода
Если устройство ввода-вывода завершило свою работу и готово вернуть результат, то какой-то поток, который был заблокирован в ожидании результата
данной операции, теперь может быть готов к выполнению. Планировщик должен решить, какой из заблокированных потоков или каких-либо других
потоков должен продолжить свое выполнение.

### 12) Основные механизмы планирования в интерактивных системах
#### Циклическое планирование
Каждому потоку назначается определенный квант времени (квант - интервал времени, в течение которого потоку позволено выполняться).
Для реализации квантов операционная система устанавливает специальный **таймер, который генерирует сигнал прерывания** по истечении
некоторого интервала времени.

Если поток к завершению своего кванта все ещё выполняется, то он прерывается принудительно и происходит context switch, позволяя другому
потоку поработать.

Если поток завершил свое выполнение, заблокировал или отдал возможность выполняться добровольно, то переключение контекста происходит именно в
этот момент, раньше завершения кванта времени.

Отработавший поток помещается в конец очереди, и все потоки выполняются по кругу снова и снова.

#### Приоритетное планирование
В циклическом планировании все потоки равнозначны, данный же механизм позволяет ввести определенную политику для потоков, что различные
потоки будут иметь различные приоритеты. Тогда следующий поток для выполнения выбирается из тех готовых потоков, которые имеют наивысший
приоритет перед остальными.

Однако, здесь всплывается проблема бесконечного выполнения высокоприоритетных потоков. Существует несколько решений данной проблемы:
 1) По истечении определенного промежутка времени каждый раз снижать приоритет текущего выполняемого потока. Если это приведет к тому, что
 следующий в очереди готовых потоков будет иметь приоритет выше, чем текущий, то произойдет перелючение контекста.
 2) Назначать каждому потоку максимальный квант времени, который он может проработать. Как только квант времени будет исчерпан, произойдет
 переключение контекста. Как только все потоки отработают, потокам будет снова назначен квант времени.

Приоритетное планировани бывает **статическим** и **динамическим**:
 - В статическим режиме различным задачач приоритеты присваиваются **при старте работы**. Данный режим проще в реализации.
 - В динамическом режиме различным задачам могут назначаться приоритеты **во время выполнения**, помимо первоначального назначения приоритета.
 Это позволяет реагировать на изменения в среде и выполнять определенные задачи в зависимости от ситуации.

### 13) Режим ядра и пользователя. Процесс смены режима
- Режим ядра позволяет иметь доступ **ко всей памяти**, **прямой доступ к аппаратному обеспечению** и выполнять любые процессорные инструкции.
Если в режиме ядра произойдет ошибка, это может привести к остановке работы всего компьютера, потребовав дальнейшеую перезагрузку, поэтому в
ядре предусмотрено несколько уровней доступа и механизмов защиты.
- Режим пользователя предоставляет доступ только **к определенным участкам памяти**, а **доступ к аппаратному обеспечению ограничен**.
Все потоки в операционной системе выполняются в режиме пользователя, и если им требуется доступ к аппаратному обеспечению
(ввод с клавиатуры, прочитать данные с диска и прочее) или выполнению ограниченной инструкции, они должны обратиться сперва к ядру
операционной системы во избежание ошибок. Такие обращения к операционной системе называются **system call (syscall)**.
Ошибки в таком режиме не катастрофичны и всегда исправимы.

Следует понять, что системные вызовы **не переводят работу программы в режим ядра**, а только выполняют необходимые инструкции на стороне ядра и
возвращают обратно требуемый результат.

### 14) Реализации потоков на уровне ядра и уровне пользователя
#### Потоки на уровне пользователя
В данной реализации потоки реализованы на пользовательском уровне, а значит, ядру ничего ни о каких потоках не известно. Ядро работает с потоками
как с однопоточными процессами. Потоки запускаются поверх *системы поддержки исполнения программ* (run-time system), которая управляет потоками.
Run-time система находится внутри процесса.
Также, так как ядру ничего неизвестно о потоках и нет данных о них, процессам придется хранить *таблицу потоков* (аналогична с таблицей процессов),
чтобы отслеживать потоки, которые выполняются внутри процесса. В таблице потоков хранится такая информация о потоках, как: указатель стека, регистр,
состояние потока и прочее (все, что нужно для работы потоков, опять же аналогия с процессами).

**Достоинства:**
- Потоки могут быть реализованы на ОСях (как библиотеки), которые даже не поддерживают потоки (а только процессы).
 Но вряд ли сейчас это актуально вообще
- Переключение потоков происходит быстрее, так как нет необходимости переключения в режим ядра. Все данные уже есть на стороне пользователя:
    1) Сохранение данных в стек тоже не требуется, данные могут быть сохранены в таблицу потоков (стек находится в таблице потоков,
    а не в ядре)
    2) Сохранение данных и вызов планировщика - это локальные процедуры и могут быть вызваны сразу с пользовательского уровня. Как итог,
    переключения в режим ядра вообще не происходит.
- Система поддержки исполнения программ владеет информацией о том, чем занимаются все потоки процесса, поэтому может лучше управлять работой
потоков и временем работы каждого потока. Ядро такой информацией не обладает (данная проблема может решиться использованием приоритетов, но это
универсальное решение, а в run-time система может быть какая-то другая, специфическая информация, поэтому тут выигрывают потоки на стороне
пользователя)

**Недостатки:**
- При выполнении блокирующего вызова в одном потоке, блокируются все потоки данного процесса, ведь ядро думает, что работает с одним процессом,
и приписывает этому процессу единое состояние выполнения: блокируется 1 поток (как думает ядро) - блокируется весь процесс со всеми потоками (как
происходит на самом деле)
 Как решение проблемы могут использоваться неблокирующие системные вызовы, но нужна их поддержка. Также, может использоваться мультиплексор select.
- Не поддерживается работа аппаратного таймера с пользователскими потоками, соответственно, не возможно будет планирование выделениия квантов
времени потокам, поэтому потокам придется вызывать функции уступания процессорного времени самостоятельно, и только тогда планировщик сможет
планировать работу, иначе поток будет работать бесконечно

#### Потоки на уровне ядра
В данной реализации уже нет необходимости в таблице потоков *в каждом процессе* и нет необходимости в run-time системе. Вместо этого, теперь
аналогичная таблица потоков находится на стороне ядра, где отслеживаются *все потоки* системы.

Однако, теперь, когда нужно создать или уничтожить поток, должны производиться обращения к ядру.

Также, разница заключается в том, что планировщик в run-time системе работал только с потоками внутри *только этого процесса*, пока ядро не
отдавало процессорное время другому процессу (и уже работала другая run-time система только с собственными потоками). Ядро же теперь знает о всех
потоках системы и может отдавать процессорное время как потоку из одного процесса, так и потоку из другого процесса.

**Достоинства**
- Не нужно мучиться с проблемой блокирования всех потоков, в отличие от реализации потоков на пользовательском уровне. Блокируется только один
поток, так как ядро теперь знает о существовании потоков

**Недостатки**
- Создание и уничтожение потоков требует более высоких затрат

### 14) что такое зелёный поток? чем он отличается от обычного потока?
**Зеленый поток** - это поток, который управляется полностью виртуальной машиной или программным обеспечением без помощи операционной системы.
Зеленые потоки выполняются в пространстве пользователя, поэтому они могут быть реализованы в тех ОСях, которые не поддерживают потоки на
уровне операционной системы.

### 15) операционная система (например, linux) решила, что данный процесс должен запустится. Что это вообще означает, и какие операционная система делает действия в этом месте.
Тут происходит context switch. Он мог быть вызван данными ситуациями (возьму из пункта про context switch):
 1) При создании нового потока
 2) При завершении работы потока
 3) При блокировке потока в ожидании результата блокирующей операции (операция ввода-вывода, блокировка на семафоре или мьютексе или другая
причина)
 4) При возникновении прерывания ввода-вывода

### 16) Создать новый процесс дорого, или дешево с точки зрения ресурсов ОС? Почему так? Как вообще создаются процессы? Откуда они изначально берутся
Создание процесса - дорого. Но вообще это зависит от ОСи. Потому что процесс должен описывать программу полностью: таблицы всех открытых
файлов, потоков, адресное пространство. Все это должно инициализироваться. Однако, например, в Unix новый созданный процесс полностью копирует
родительский процесс и имеет абсолютно такие же данные, тем самым они не инициализируются снова. Только после выполнения процедуры exec()
процесс инициализируется новыми данными. Данный пример показывает, что все зависит от ОСи.

Все процессы в Unix начинаются с одного стартового - процесса **init**, который создается во время запуска системы (в Windows есть такой же
аналогичный - **System Idle Process**). Можно сказать, что в вершине иерархии абсолютно всех процессов в Unix стоит процесс **init**.

Создать процесс в Unix можно командой **fork()**.

### 17) Создать новый поток дорого, или дешево с точки зрения ресурсов ОС? Почему так? Кто создаёт потоки? Откуда первый поток берётся?
Создать поток дешевле, чем процесс, из-за того, что поток всего лишь содержит необходимые данные для работы процедур, а не описывает полностью
программу.

Создать поток в Unix можно командой **pthread_create()**.

Первый поток, от которого могут быть образованы другие дочерние потоки, всегда инициализируется в созданном процессе и называется **main
thread**.

### 18) Есть программа. Она читает из сокета. Если она будет читать из сокета в 10 потоков, она всегда будет быстрее, чем с 1 потоком? Объясни почему так

### 19) Есть программа. Она считает сумму какого-то большого массива данных. Она всегда будет быстрее в 10 потоков, чем если бы в ней был 1 поток? Объясни почему так?
Да, будет быстрее. Можно дать определенный промежуток массива и распределить работу на 10 потоков. Каждый поток посчитает свой промежуток и вернет результат, из полученных
результатов получится сумма всего массива. Поэтому многопоточность применяется активно в науке - ученым нужно много считать много чисел (например, умножение больших матриц).

### 20) Есть процесс - музыкальный плеер. Каким образом ты слышишь постоянно музыку, но при этом работают и другие процессы

### 22) Что такое примитивы (методы) синхронизации, и как это вообще работает? Если бы ты писал свой язык программирования, в твоем языке могли бы появится примитивы синхронизации?
**Примитивы синхронизации** - механизмы, которые применяются для правильного взаимодействия потоков с другими потоками и предотвращения состязательной ситуации
(race condition).

Примитивы синхронизации позволяют разрешать следующие ситуации:
 1) Когда несколько потоков обращаются к критическом области (общие файлы и данные)
 2) Когда один поток ожидает результата работы второго потока

### 23) Основные примитивы синхронизации

#### Критические области

#### Семафоры

#### Мьютексты

#### Фьютексы

#### Спинлоки

#### Мониторы

### 23) Существует много всяких примитивов синронизации. Я - человек, который ничего об этом не знает. Расскажи мне алгоритм, как выбрать какой-то примитив синхронизации для моей задачи. Типо, если мне надо ***, и ***, то я должен выбрать *** потому, что.

### 24) А операции с примитивами синхронизации - они вообще дорогие? Можно что-то сделать, для того чтобы их не пришлось ипользовать, или их использование было минимальным?

### 25) Монитор и мьютекс - это одно и тоже, или нет?
