### Содержание:
- [Что такое процесс](https://github.com/blinky-z/ThreadsLearn#1-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81)
- [Что такое поток](https://github.com/blinky-z/ThreadsLearn#2-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA)
- [Почему нужна поддержка множества потоков внутри одного процесса](https://github.com/blinky-z/ThreadsLearn#3-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)
- [Отличие процесса от потока](https://github.com/blinky-z/ThreadsLearn#4-%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%BE%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
- [Что такое счётчик команд](https://github.com/blinky-z/ThreadsLearn#5-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D1%87%D1%91%D1%82%D1%87%D0%B8%D0%BA-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4)
- [Состояния потоков](https://github.com/blinky-z/ThreadsLearn#6-%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Почему создание и уничтожение процессов дороже, чем потоков](https://github.com/blinky-z/ThreadsLearn#7-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%B4%D0%BE%D1%80%D0%BE%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Что такое многозадачность](https://github.com/blinky-z/ThreadsLearn#8-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Для чего нужна многозадачность](https://github.com/blinky-z/ThreadsLearn#9-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Вытесняющая и кооперативная многозадачность](https://github.com/blinky-z/ThreadsLearn#10-%D0%92%D1%8B%D1%82%D0%B5%D1%81%D0%BD%D1%8F%D1%8E%D1%89%D0%B0%D1%8F-%D0%B8-%D0%BA%D0%BE%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Что такое Context switch](https://github.com/blinky-z/ThreadsLearn#11-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-context-switch)
- [Что такое планировщик задач в ОС](https://github.com/blinky-z/ThreadsLearn#12-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87-%D0%B2-%D0%9E%D0%A1)
- [Как работает планировщик задач](https://github.com/blinky-z/ThreadsLearn#13-%D0%9A%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87)
- [Основные алгоритмы планирования в интерактивных системах](https://github.com/blinky-z/ThreadsLearn#14-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D1%85)
- [Режим ядра и пользователя](https://github.com/blinky-z/ThreadsLearn#15-%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC-%D1%8F%D0%B4%D1%80%D0%B0-%D0%B8-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
- [Реализации потоков на уровне ядра и уровне пользователя](https://github.com/blinky-z/ThreadsLearn#16-%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
- [Что такое зелёный поток? чем он отличается от обычного потока?](https://github.com/blinky-z/ThreadsLearn#17-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%B5%D0%BB%D1%91%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%82-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
- [операционная система (например, linux) решила, что данный процесс должен запустится. Что это вообще означает, и какие операционная система делает действия в этом месте](https://github.com/blinky-z/ThreadsLearn#18-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-linux-%D1%80%D0%B5%D1%88%D0%B8%D0%BB%D0%B0-%D1%87%D1%82%D0%BE-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%81%D1%8F-%D0%A7%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-%D0%B2%D0%BE%D0%BE%D0%B1%D1%89%D0%B5-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D0%B2-%D1%8D%D1%82%D0%BE%D0%BC-%D0%BC%D0%B5%D1%81%D1%82%D0%B5)
- [Создать новый процесс дорого, или дешево с точки зрения ресурсов ОС? Почему так? Как вообще создаются процессы? Откуда они изначально берутся](https://github.com/blinky-z/ThreadsLearn#19-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%B4%D0%BE%D1%80%D0%BE%D0%B3%D0%BE-%D0%B8%D0%BB%D0%B8-%D0%B4%D0%B5%D1%88%D0%B5%D0%B2%D0%BE-%D1%81-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D0%B7%D1%80%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-%D0%9E%D0%A1-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%82%D0%B0%D0%BA-%D0%9A%D0%B0%D0%BA-%D0%B2%D0%BE%D0%BE%D0%B1%D1%89%D0%B5-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%9E%D1%82%D0%BA%D1%83%D0%B4%D0%B0-%D0%BE%D0%BD%D0%B8-%D0%B8%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B1%D0%B5%D1%80%D1%83%D1%82%D1%81%D1%8F)
- [Создать новый поток дорого, или дешево с точки зрения ресурсов ОС? Почему так? Кто создаёт потоки? Откуда первый поток берётся?](https://github.com/blinky-z/ThreadsLearn#20-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D0%B4%D0%BE%D1%80%D0%BE%D0%B3%D0%BE-%D0%B8%D0%BB%D0%B8-%D0%B4%D0%B5%D1%88%D0%B5%D0%B2%D0%BE-%D1%81-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D0%B7%D1%80%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-%D0%9E%D0%A1-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%82%D0%B0%D0%BA-%D0%9A%D1%82%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%91%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%9E%D1%82%D0%BA%D1%83%D0%B4%D0%B0-%D0%BF%D0%B5%D1%80%D0%B2%D1%8B%D0%B9-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D0%B1%D0%B5%D1%80%D1%91%D1%82%D1%81%D1%8F)
- [Есть программа. Она читает из сокета. Если она будет читать из сокета в 10 потоков, она всегда будет быстрее, чем с 1 потоком?](https://github.com/blinky-z/ThreadsLearn#21-%D0%95%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%9E%D0%BD%D0%B0-%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82-%D0%B8%D0%B7-%D1%81%D0%BE%D0%BA%D0%B5%D1%82%D0%B0-%D0%95%D1%81%D0%BB%D0%B8-%D0%BE%D0%BD%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D1%87%D0%B8%D1%82%D0%B0%D1%82%D1%8C-%D0%B8%D0%B7-%D1%81%D0%BE%D0%BA%D0%B5%D1%82%D0%B0-%D0%B2-10-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%BE%D0%BD%D0%B0-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B5%D0%B5-%D1%87%D0%B5%D0%BC-%D1%81-1-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC)
- [Есть программа. Она считает сумму какого-то большого массива данных. Она всегда будет быстрее в 10 потоков, чем если бы в ней был 1 поток? Объясни почему так?](https://github.com/blinky-z/ThreadsLearn#22-%D0%95%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%9E%D0%BD%D0%B0-%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82-%D1%81%D1%83%D0%BC%D0%BC%D1%83-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE-%D1%82%D0%BE-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%9E%D0%BD%D0%B0-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B5%D0%B5-%D0%B2-10-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D1%87%D0%B5%D0%BC-%D0%B5%D1%81%D0%BB%D0%B8-%D0%B1%D1%8B-%D0%B2-%D0%BD%D0%B5%D0%B9-%D0%B1%D1%8B%D0%BB-1-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D0%9E%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%82%D0%B0%D0%BA)
- [Есть процесс - музыкальный плеер. Каким образом ты слышишь постоянно музыку, но при этом работают и другие процессы](https://github.com/blinky-z/ThreadsLearn#23-%D0%95%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81---%D0%BC%D1%83%D0%B7%D1%8B%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BB%D0%B5%D0%B5%D1%80-%D0%9A%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D1%82%D1%8B-%D1%81%D0%BB%D1%8B%D1%88%D0%B8%D1%88%D1%8C-%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%BE-%D0%BC%D1%83%D0%B7%D1%8B%D0%BA%D1%83-%D0%BD%D0%BE-%D0%BF%D1%80%D0%B8-%D1%8D%D1%82%D0%BE%D0%BC-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%B8-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B)
- [Что такое примитивы синхронизации, и как это вообще работает? Если бы ты писал свой язык программирования, в твоем языке могли бы появится примитивы синхронизации?](https://github.com/blinky-z/ThreadsLearn#24-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D0%B2%D0%BE%D0%BE%D0%B1%D1%89%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%95%D1%81%D0%BB%D0%B8-%D0%B1%D1%8B-%D1%82%D1%8B-%D0%BF%D0%B8%D1%81%D0%B0%D0%BB-%D1%81%D0%B2%D0%BE%D0%B9-%D1%8F%D0%B7%D1%8B%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-%D1%82%D0%B2%D0%BE%D0%B5%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-%D0%BC%D0%BE%D0%B3%D0%BB%D0%B8-%D0%B1%D1%8B-%D0%BF%D0%BE%D1%8F%D0%B2%D0%B8%D1%82%D1%81%D1%8F-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
- [Основные примитивы синхронизации](https://github.com/blinky-z/ThreadsLearn#25-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
- [Монитор и мьютекс - это одно и тоже, или нет?](https://github.com/blinky-z/ThreadsLearn#28-%D0%9C%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80-%D0%B8-%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81---%D1%8D%D1%82%D0%BE-%D0%BE%D0%B4%D0%BD%D0%BE-%D0%B8-%D1%82%D0%BE%D0%B6%D0%B5-%D0%B8%D0%BB%D0%B8-%D0%BD%D0%B5%D1%82)
- [Как выбрать подходящий примитив синхронизации](https://github.com/blinky-z/ThreadsLearn/tree/postj#27-%D0%9A%D0%B0%D0%BA-%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%D1%8F%D1%89%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
- [Когда лучше применять спинлок и что такое недолгое ожидание?](https://github.com/blinky-z/ThreadsLearn/tree/postj#28-%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BB%D1%83%D1%87%D1%88%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D1%82%D1%8C-%D1%81%D0%BF%D0%B8%D0%BD%D0%BB%D0%BE%D0%BA-%D0%B8-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BD%D0%B5%D0%B4%D0%BE%D0%BB%D0%B3%D0%BE%D0%B5-%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5)
- [А операции с примитивами синхронизации - они вообще дорогие? Можно что-то сделать, для того чтобы их не пришлось ипользовать, или их использование было минимальным?](https://github.com/blinky-z/ThreadsLearn/tree/postj#29-%D0%90-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D1%81-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8---%D0%BE%D0%BD%D0%B8-%D0%B2%D0%BE%D0%BE%D0%B1%D1%89%D0%B5-%D0%B4%D0%BE%D1%80%D0%BE%D0%B3%D0%B8%D0%B5-%D0%9C%D0%BE%D0%B6%D0%BD%D0%BE-%D1%87%D1%82%D0%BE-%D1%82%D0%BE-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%B4%D0%BB%D1%8F-%D1%82%D0%BE%D0%B3%D0%BE-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%B8%D1%85-%D0%BD%D0%B5-%D0%BF%D1%80%D0%B8%D1%88%D0%BB%D0%BE%D1%81%D1%8C-%D0%B8%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B8%D0%BB%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D1%8B%D0%BB%D0%BE-%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC)

### 1) Что такое процесс
**Процесс** - это абстракция, реализованная на программном уровне - уровне операционной системы.

Процесс был придуман для организации всех данных, необходимых для работы программы. Можно сказать, что процесс - это просто контейнер, в котором находятся *ресурсы программы*.

**Элементы процесса:**
- *адресное пространство*
- *потоки*
- *открытые файлы*
- *дочерние процессы*

Просто к слову, адресное пространство - это не только пространство в оперативной памяти (начало адресов и конец), но также может
иногда использоваться и виртуальная память. Адресное пространство - это абстрактная вещь, через которую программа может получать
доступ к памяти например так: memory[0], не зная к какой памяти вообще обращается, а доступ к оперативной или виртуальной памяти
обеспечивают другие вещи.

-------

### 2) Что такое поток
 **Поток** - это сущность, в которой выполняются процедуры программы. Поток легче, чем процесс, и создание потока стоит дешевле.

Потоки используют адресное пространство процесса, которому они принадлежат, поэтому потоки внутри одного процесса могут обмениваться данными и взаимодействовать с другими потоками.

**Элементы потока:**
 - *Счётчик команд*
 - *Регистры*
 - *Стек*

-------

### 3) Почему нужна поддержка множества потоков внутри одного процесса
Поддержка множества потоков внутри одного процесса нужна потому, что для работы программы обычно требуется выполнение множества задач.
Также, часто, задачам необходимо обмениваться данными, использовать общие данные или результаты других задач.
Такую возможность предоставляют потоки внутри процесса, так как они используют адресное пространство процесса, которому принадлежат.

Конечно, можно было бы создать ещё один процесс под задачу, но:
  - у процесса будет отдельное адресное пространство и данные
  - по вопросам производительности: создание и уничтожение процесса дороже, чем создание потока

-------

### 4) Отличие процесса от потока
Процесс *описывает*  выполняющуюся программу (описывает, значит содержит необходимые ресурсы для работы программы), а сама программа же, её *процедуры выполняются в потоках*. Главное надо понимать, что программа - это не один поток.

**Программа** - это *набор взаимодейстущих между собой потоков*, и может быть, даже процессов.

Конечно, может быть 1 поток, если это какая-то совсем простая программа.
А в самых простейших операционных системах процесс имеет только единственный поток выполнения, поэтому в таких случаях немного размываются границы между потоками и процессами, т.к. 1 процесс - это 1 поток, но это так, к слову.

 **Вывод:** процесс - это всего лишь *способ сгруппировать взаимосвязанные данные, ресурсы*, а вот потоки - уже именно то, *что
распределяется и выполняется на процессоре* . А если кто-то говорит о том, что процессы сменяются и выделяется время процессам,
наверное, имеется в виду процесс с единственным потоком в простых ОСях, так как процессы сменяться не могут, сменяются и
выполняются на процессоре только потоки. Context switch тоже относится только к потокам.

-------

### 5) Что такое счётчик команд 

**Счётчик команд (Program counter, Instruction Pointer)** - регистр процессора, который хранит адрес ячейки памяти, в которой содержится команда, которую необходимо выполнить следующей.

Счётчик команд - это один из наиболее важных регистров процессора, так как позволяет выполнять алгоритмы (простая программа выводящая Hello, World - тоже алгоритм по сути. Алгоритм - это абстрактная вещь). Последовательности команд и являются алгоритмами по сути.

После взятия команды из регистра счётчик увеличивается (инкрементируется), и в регистре будет храниться следующая команда, которую необходимо выполнить.

В зависимости от архитектуры, в счётчике команд может храниться текущая выполняемая команда, а не следующая, если инкрементация предшествует взятию команды.

-------

### 6) Состояния потоков
 - *Выполняемый*
 - *Готовый* (процесс не заблокирован, и может выполняться, однако, в данный момент времени на процессоре выполняется другой поток. Когда
происходит смена потоков, то новым выполняемым потоком становится только один из готовых потоков).
 - *Заблокированный* (обычно ожидает результатов завершения блокирующей операции)

-------

### 7) Почему создание и уничтожение процессов дороже, чем потоков
Процесс - полностью описывает программу: адресное пространство, потоки, открытые файлы, дочерние процессы, все эти таблицы данных должны инициализироваться при создании процесса. Тогда как потоки не хранят таких данных (т.к. они используют данные процесса, к которому они прикреплены), а хранит только счетчик команд, стек и регистры (поэтому потоки также называют "легкими процессами").

-------

### 8) Что такое многозадачность
**Многозадачность** - свойство ОСи, позволяющее обеспечивать выполнение сразу нескольких задач на одном процессоре. Многозадачность может быть **параллельной** (если каждая задача выполняется на отдельном процессоре) или **псевдопараллельной** (если задачи выполняются на одном процессоре).

-------

### 9) Для чего нужна многозадачность
Многозадачность нужна для того, чтобы на процессоре могли выполняться сразу несколько потоков.

Данная необходимость возникла потому, что крайне нежелательная пустая трата процессорного времени, то есть простаивание процессора.
Простаивание возникает тогда, когда какой-либо поток блокируется в ожидании результата блокирующей операции. Тогда, лучше отдать
процессорное время другому потоку, чтобы процессор не простаивал, таким образом повышая производительность.

Также, многозадачность позволяет запускать сразу несколько программ на компьютере.

-------

### 10) Вытесняющая и кооперативная многозадачность
Существуют **вытесняющие** и **кооперативные** алгоритмы планирования:
 - При вытесняющем режиме работы потоки могут **прерываться принудительно** при истечении отведенного им кванта времени.
 - При невытесняющем режиме работы потоки могут **работать столько, сколько им необходимо**. Переключение контекста произойдет **только** при завершении работы потока, блокировке или при добровольном предоставлении возможности выполнения (например, функция *yield()* в Unix). При использовании кооперативной многозадачности нужно быть предельно осторожным, иначе может возникнуть ситуация, когда один поток полностью захватит процессор.

**Применение вытесняющей многозадачности:**
вытесняющая многозадачность применяется в интерактивных системах. В такой системе ни один поток не может получать больше процессорного времени, чем какой-либо другой эквивалентный ему: каждый поток должен получать справедливое процессорное время. Значит, потоки не могут сами решать, сколько им выполняться, поэтому в интерактивной среде следует применять вытесняющую многозадачность.

Вытесняющая многозадачность называется так потому, что потоки будто вытесняют друг друга, ведь каждый хочет выполняться.

**Применение кооперативной многозадачности (cooperative multitasking):**
кооперативная многозадачность применяется в системах реального времени, так как в такой среде потоки знают, что они могут запускаться только на непродолжительные отрезки времени. Также, в среде реального времени потоки запускаются только для решения определённой задачи с последующим самостоятельным блокированием, в отличие от интерактивных систем, где задачи произвольны и не преследуют цель решить конкретную задачу. Кроме того, из-за отсутствия принудительного переключения потоков, повышается производительность и эффективность работы системы, так как количество прерываний сильно сокращается.

Кооперативная многозадачность называется так потому, что потоки должны кооперировать между собой, то есть правильно распределять время выполнения, передавая возможность работы другим потокам, чтобы происходила работа системы. Потоки не хотят выполняться, пока им не передадут возможность выполнения, все потоки терпеливо ждут своей очереди, потому что знают, что каждый выполняет свою определённую задачу, и в разные моменты времени требуется выполнение определённых задач для работы программы.

**Вывод:** кооперативная многозадачность может быть особенно на системах реального времени. Вытесняющая многозадачность подходит лучше для интерактивных систем.

-------

### 11) Что такое Context switch
**Context switch (переключение контекста)** - это процесс сохранения состояния прерванного потока и загрузка состояния следующего потока (который тоже был сохранен раннее), к выполнению которого приступит процессор. Следует отметить, что Context switch не прерывает текущий выполняемый поток, прерывание потока происходит благодаря **прерываниям**: происходит прерывание (текущий поток приостанавливается), вызывается планировщик, планировщик инициирует context switch.

Вызов Context switch инициируется *планировщиком*. Планировщик должен решить, какой поток будет выполняться следующим, и происходит context switch, который загружает состояние данного потока.
Однако, если планировщик решит, что потоки сменяться не должны и прервавшемуся потоку разрешается работать дальше, context switch может и не произойти.

-------

### 12) Что такое планировщик задач в ОС
**Планировщик задач** - это программа (демон), на которую ложится задача выбора потока, который будет выполняться следующим. Планировщик применяется в многозадачности.

-------

### 13) Как работает планировщик задач
**Алгоритм планирования** - алгоритм, который используется в планировщике. От алгоритма планирования зависит распределение порядка работы потоков.

**Основной принцип планирования** - предоставление каждому потоку **справедливой** доли процессорного времени. Однако, в некоторых алгоритмах планирования различные категории потоков могут получать большее процессорное время, чем потоки с низким приоритетом

Алгоритмы планирования зависят от среды выполнения:
 - *Пакетные системы*
 - *Интерактивная система*
 - *Система реального времени*

**Вызов планировщика происходит в следующих ситуациях:**
 1) *При создании нового потока*
 2) *При завершении работы потока*
 3) *При блокировке потока в ожидании результата блокирующей операции* (операция ввода-вывода, блокировка на семафоре или мьютексе или другая
причина блокировки)
 4) *При возникновении прерывания ввода-вывода*

**Рассмотрим работу планировщика в описанных выше ситуациях:**
#### Создание нового потока
Планировщик должен решить, какому потоку позволить выполняться следующим: дочерний (только что созданный) или родительский (инициировавший создание нового потока), или вообще какой-нибудь третий поток.
#### Завершение работы потока
Когда поток завершает свою работу, необходимо выбрать следующий поток для выполнения
#### Блокировка потока
Когда поток блокируется, планировщик должен выбрать поток, который будет выполняться следующим во избежании пустой траты процессорного времени
#### Возникновение прерывания ввода-вывода
Если устройство ввода-вывода завершило свою работу и готово вернуть результат, то какой-то поток, который был заблокирован в ожидании результата данной операции, теперь может быть готов к выполнению. Планировщик должен решить, какой из заблокированных потоков или каких-либо других потоков должен продолжить свое выполнение.

-------

### 14) Основные алгоритмы планирования в интерактивных системах
#### 1) Циклическое планирование
Каждому потоку назначается определенный квант времени (квант - интервал времени, в течение которого потоку позволено выполняться).
Для реализации возможности приоставновки выполнения потока по истчечении кванта операционная система устанавливает специальный **таймер, который генерирует сигнал прерывания** по истечении некоторого интервала времени.

Если поток к завершению своего кванта все ещё выполняется, то он прерывается **принудительно**  и происходит context switch, позволяя другому потоку поработать.

Если поток завершил свое выполнение, заблокировал или отдал возможность выполняться добровольно, то переключение контекста происходит именно в
этот момент, раньше завершения кванта времени.

Отработавший поток помещается в конец очереди, и все потоки выполняются по кругу снова и снова.

#### 2) Приоритетное планирование
В циклическом планировании все потоки равнозначны, данный же механизм позволяет ввести определенную политику для потоков, что различные потоки будут иметь различные приоритеты. Тогда следующий поток для выполнения выбирается из тех готовых потоков, которые имеют наивысший приоритет перед остальными.

Однако, здесь всплывается проблема бесконечного выполнения высокоприоритетных потоков. Существует несколько решений данной проблемы:
 1) По истечении определенного промежутка времени каждый раз снижать приоритет текущего выполняемого потока. Если это приведет к тому, что следующий в очереди готовых потоков будет иметь приоритет выше, чем текущий, то произойдет переключение контекста.
 2) Назначать каждому потоку максимальный квант времени, который он может проработать. Как только квант времени будет исчерпан, произойдет переключение контекста. Как только все потоки отработают, потокам будет снова назначен квант времени.

Приоритетное планирование бывает **статическим** и **динамическим**:
 - В статическим режиме различным задачач приоритеты присваиваются **при старте работы программы**. Данный режим проще в реализации.
 - В динамическом режиме различным задачам могут назначаться приоритеты **во время выполнения**, помимо первоначального назначения приоритета.
 Это позволяет реагировать на изменения в среде и выполнять определенные задачи незамедлительно в зависимости от ситуации.

-------

### 15) Режим ядра и пользователя
- **Режим ядра:** позволяет иметь доступ *ко всей памяти*, *прямой доступ к аппаратному обеспечению* и выполнять любые процессорные инструкции.
Если в режиме ядра произойдет ошибка, это может привести к остановке работы всего компьютера, потребовав дальнейшеую перезагрузку, поэтому в ядре предусмотрено несколько уровней доступа и механизмов защиты.
- **Режим пользователя:** предоставляет доступ только *к определенным участкам памяти*, а *доступ к аппаратному обеспечению ограничен*.
Все потоки в операционной системе выполняются в режиме пользователя, и если им требуется доступ к аппаратному обеспечению
(ввод с клавиатуры, прочитать данные с диска и прочее) или выполнению ограниченной инструкции, они должны обратиться сперва к ядру операционной системы во избежание ошибок. Такие обращения к операционной системе называются **system call (syscall)**.
Ошибки в таком режиме не катастрофичны и всегда исправимы.

Следует понять, что системные вызовы **не переводят работу программы в режим ядра**, а только выполняют необходимые инструкции на стороне ядра и возвращают обратно требуемый результат.

-------

### 16) Реализации потоков на уровне ядра и уровне пользователя
#### Потоки на уровне пользователя
В данной реализации потоки реализованы на пользовательском уровне, а значит, ядру ничего ни о каких потоках не известно. Ядро работает с потоками как с однопоточными процессами. Потоки запускаются поверх *системы поддержки исполнения программ* (run-time system), которая управляет потоками.
Run-time система находится внутри процесса.
Также, так как ядру ничего неизвестно о потоках и нет данных о них, процессам придется хранить *таблицу потоков* (аналогична с таблицей процессов),
чтобы отслеживать потоки, которые выполняются внутри процесса. В таблице потоков хранится такая информация о потоках, как: указатель стека, регистр,
состояние потока и прочее (все, что нужно для работы потоков, опять же аналогия с процессами).

**Достоинства:**
- Потоки могут быть реализованы на ОСях (как библиотеки), которые даже не поддерживают потоки (а только процессы).
- Переключение потоков происходит быстрее, так как нет необходимости переключения в режим ядра. Все данные уже есть на стороне пользователя:
    1) Сохранение данных в стек тоже не требуется, данные могут быть сохранены в таблицу потоков (стек находится в таблице потоков, а не в ядре)
    2) Сохранение данных и вызов планировщика - это локальные процедуры и могут быть вызваны сразу с пользовательского уровня. Как итог, переключения в режим ядра вообще не происходит.
- Система поддержки исполнения программ владеет информацией о том, чем занимаются все потоки процесса, поэтому может лучше управлять работой потоков и временем работы каждого потока. Ядро такой информацией не обладает (данная проблема может решиться использованием приоритетов, но это
универсальное решение, а в run-time система может быть какая-то другая, специфическая информация, поэтому тут выигрывают потоки на стороне пользователя)

**Недостатки:**
- При выполнении блокирующего вызова в одном потоке, блокируются все потоки данного процесса, ведь ядро думает, что работает с одним процессом, и приписывает этому процессу единое состояние выполнения: блокируется 1 поток (как думает ядро) - блокируется весь процесс со всеми потоками (как происходит на самом деле)
 Как решение проблемы могут использоваться неблокирующие системные вызовы, но нужна их поддержка. Также, может использоваться мультиплексор select.
- Не поддерживается работа аппаратного таймера с пользовательскими потоками, соответственно, не возможно будет планирование выделениия квантов
времени потокам, поэтому потокам придется вызывать функции уступания процессорного времени самостоятельно, и только тогда планировщик сможет планировать работу, иначе поток будет работать бесконечно

#### Потоки на уровне ядра
В данной реализации уже нет необходимости в таблице потоков *в каждом процессе* и нет необходимости в run-time системе. Вместо этого, аналогичная таблица потоков находится на стороне ядра, где отслеживаются *все потоки* системы.

Однако, теперь, когда нужно создать или уничтожить поток, должны производиться обращения к ядру.

Также, разница заключается в том, что планировщик в run-time системе работал только с потоками внутри *только этого процесса*, пока ядро не отдавало процессорное время другому процессу (и уже работала другая run-time система только с собственными потоками). Ядро же теперь знает о всех потоках системы и может отдавать процессорное время как потоку из одного процесса, так и потоку из другого процесса.

**Достоинства**
- Не нужно мучиться с проблемой блокирования всех потоков, в отличие от реализации потоков на пользовательском уровне. Блокируется только один поток, так как ядро теперь знает о существовании потоков

**Недостатки**
- Создание и уничтожение потоков требует более высоких затрат

-------

### 17) Что такое зелёный поток? чем он отличается от обычного потока?
**Зеленый поток** - это поток, который управляется полностью виртуальной машиной или программным обеспечением без помощи операционной системы.
Зеленые потоки выполняются в пространстве пользователя, поэтому они могут быть реализованы в тех ОСях, которые не поддерживают потоки на уровне операционной системы.

-------

### 18) операционная система (например, linux) решила, что данный процесс должен запустится. Что это вообще означает, и какие операционная система делает действия в этом месте.

Операционная система создает процесс для этой программы и каждый процесс получает первоначальный поток выполнения, который в дальнейшем может порождать другие потоки и процессы. Так, программа начинается всего с одного процесса, и по мере инициализации создаются новые процессы и потоки, и в итоге программа становится полностью запущенной и готовой к работе. Но по ходу работы она может создавать еще потоки.

-------

### 19) Создать новый процесс дорого, или дешево с точки зрения ресурсов ОС? Почему так? Как вообще создаются процессы? Откуда они изначально берутся
Создание процесса - дорого. Но вообще это зависит от ОСи. Потому что процесс должен описывать программу полностью: таблицы всех открытых файлов, потоков, адресное пространство. Все это должно инициализироваться. Однако, например, в Unix новый созданный процесс полностью копирует родительский процесс и имеет абсолютно такие же данные, тем самым они не инициализируются снова, поэтому позволяет проделать какие-либо команды перед непосредственным переходом к выполнению процедуры. Только после выполнения процедуры *exec()*  процесс инициализируется новыми данными. В Windows же, новый поток сразу инициализируется новыми данными. Данный пример показывает, что некоторые детали реализации зависят от ОСи.

Все процессы в Unix начинаются с одного стартового - процесса **init**, который создается во время запуска системы (в Windows есть аналогичный стартовый процесс - **System Idle Process**). Можно сказать, что в вершине иерархии абсолютно всех процессов в Unix стоит процесс **init** (в Windows иерархии процессов нет - все процессы равнозначны).

Создать процесс в Unix можно командой *fork()*.

-------

### 20) Создать новый поток дорого, или дешево с точки зрения ресурсов ОС? Почему так? Кто создаёт потоки? Откуда первый поток берётся?
Создать поток дешевле, чем процесс, из-за того, что поток всего лишь содержит необходимые данные для работы процедур, а не описывает полностью программу.

Создать поток в Unix можно командой *pthread_create()*.

Первый поток, от которого могут быть образованы другие дочерние потоки, всегда инициализируется в созданном процессе и называется **main thread**.

-------

### 21) Есть программа. Она читает из сокета. Если она будет читать из сокета в 10 потоков, она всегда будет быстрее, чем с 1 потоком?
Нет, не будет, так как перед тем как взять новые данные из сокета, нужно прочитать старые, и пока старые прочитаны не будут, поток не сможет прочитать новые, то есть, единовременно только 1 поток читает данные. Значит, разделять работу на несколько потоков нет необходимости.


-------

### 22) Есть программа. Она считает сумму какого-то большого массива данных. Она всегда будет быстрее в 10 потоков, чем если бы в ней был 1 поток? Объясни почему так?
1) **В случае параллельной многозадачности (многоядерной среды):**
Да, будет быстрее. Можно распределить работу на 10 потоков, назначив каждому потоку вычисление определенного промежутка массива. Каждый поток посчитает свой промежуток и вернет результат, из полученных результатов получится сумма всего массива. Поэтому параллельные вычисления (параллельная многозадачность) активно применяются в науке - ученым нужно много считать много чисел (например, умножение больших матриц). Однако, следует учитывать то, что создав потоков больше, чем ядер, это не принесет никакого увеличения эффективности вычислений, так как параллельно все также работают только столько потоков, сколько есть ядер.
2) **В случае псевдопараллельной многозадачности (одноядерной среды):**
Нет, распределив работу на 10 потоков, вычисление не будет быстрее, а, возможно, даже займёт даже больше времени из-за траты времени на переключение потоков (хоть оно и незначительно)

-------

### 23) Есть процесс - музыкальный плеер. Каким образом ты слышишь постоянно музыку, но при этом работают и другие процессы
Проигрыш звука, музыки - это среда реального времени. Очередной буфер аудио или видео должен поставляться программой в жесткие сроки, чтобы не было задержек звука или видео.
Человеческое ухо очень чувствительно к задержкам воспроизвдения аудио, так что самое максимальное время, которое поток воспроизводящий аудио, может простаивать - около 5 мс.
Самое главное - плеер не воспроизводит звук, это всего лишь оболочка для удобного вопроизведения файлов - функции, проигрывающие аудио, называются **audio callback function**, и имеют больший приоритет.

Основные принципы для избежания потерь и задержек аудио:
1) Нельзя никогда блокировать поток, который воспроизводит аудио
2) Нужно при разработке или использовании алгоритма воспроизведния аудио смотреть не на среднее время выполнения (average case), а на *худшее время выполнения* алгоритма (worst case)

-------

### 24) Что такое примитивы синхронизации, и как это вообще работает? Если бы ты писал свой язык программирования, в твоем языке могли бы появится примитивы синхронизации?
**Примитивы синхронизации** - механизмы, позволяющие обеспечить единовременно доступ только одного потока к критической области, а также взаимодействие потоков.

Примитивы синхронизации в зависимости от типа примитива преследуют различные задачи:
 1) Взаимное исключение потоков - примитивы синхронизации гарантируют то, что единовременно с критической областью будет работать только один поток
 2) Синхронизация потоков - примитивы синхронизации гарантируют наступление тех или иных конкретных событий, то есть поток не будет работать, пока не наступило какое-то событие. Другой поток в таком случае должен гарантировать наступление данного события.

-------

### 25) Основные примитивы синхронизации

Каждый примитив синхронизации должен соблюдать следующие условия:
1. Два процесса не могут одновременно находиться в своих критических областях.
2. Не должны выстраиваться никакие предположения по поводу скорости или количества центральных процессоров.
3. Никакие процессы, выполняемые за пределами своих критических областей, не могут блокироваться любым другим процессом.
4. Процессы не должны находиться в вечном ожидании входа в свои критические области.

-------

#### 1) Спинлоки
**Спинлок**  - это лок, для блокировки которого используется *активное ожидание* (busy-waiting).

**Активное ожидание** - это абстрактный принцип, который заключается в том, чтобы постоянно проверять, пока флаг (flag) не станет определённым значением, при котором блокировка может быть произведена успешно.

Захватить спинлок можно, например, операцией *TSL (Test and Set Lock)* (блокировка шины памяти, которая запрещает другим потокам получить доступ к памяти).

**Пример реализации TSL:**
```
enter region:
    TSL REGISTER,LOCK
    CMP REGISTER,#0
    JNE enter_region
    RET
```

Пример активного ожидания: если значение LOCK было ненулевым, то нужно войти в цикл. Если значение LOCK было нулевым, то есть лок был свободным, поток успешно захватывает спинлок.

Это простой механизм, однако обладает проблемой *пустой траты процессорного времени*, так как поток не засыпает во время активного ожидания. Однако, данный алгоритм обладает и плюсами, так как не блокирует поток, что в некоторых ситуациях может быть эффективнее блокирования потока. Правильный выбор примитива синхронизации будет рассмотрен ниже.

#### 2) Семафоры
**Семафор** - это примитив синхронизации, который **ограничивает** количество потоков, которые могут работать в критической области. Семафор поддерживает подсчитывание количества активизаций семафора, благодаря этому становится возможным пропускать в критическую область более одного потока.

Пример:
```c++
semaphore mutex = 2;

void do_critical1() {
    down(&mutex); // поток 1 успешно входит в критическую область | mutex = 1
    do_critical();
    ...
}

void do_critical2() {
    down(&mutex); // поток 2 успешно входит в критическую область | mutex = 0
    do_critical();
    ...
}

void do_critical3() {
    down(&mutex); // поток 3 блокируется, так как mutex = 0
    do_critical();
    ...
}

```

Существуют две операции над семафорами - *down*  и *up*, которые являются *атомарными действиями*. Атомарность гарантирует то, что во время выполнения операции одним потоком, никакой другой поток не сможет получить доступ к семафору. Тем самым исключаются состязательные ситуации.

**Операция down():** пытается понизить значение семафора на единицу: если значение семафора равно нулю, то поток блокируется, иначе значение декрементируется и поток работает дальше.

**Операция up():** повышает значение на единицу и система разблокирует один из заблокированных на данном семафоре потоков, если таковые есть. Разблокированный поток завершает операцию down (при этом значение семафора снова становится нулевым) и продолжает работать дальше.

Рассмотрим задачу производителя и потребителя для большего понимания использования семафора:
```c++
semaphore mutex;
semaphore full;
semaphore empty;
ItemBuffer items;

void producer() {
    while (true) {
        Item item = create_item();
        down(&empty);
        down(&mutex);
        items.insert(item);
        up(&mutex);
        up(&full);
   }
}

void consumer() {
    while (true) {
        down(&full);
        down(&mutex);
        Item item = items.remove();
        up(&mutex);
        up(&empty);
        handle_item(item);
   }
}
```

Здесь, семафоры *full* и *empty* выполняют задачу **синхронизации** - они гарантируют, что производитель не будет работать, пока не будет свободных слотов (производтель заблокируется на операции ```down(&empty)```), а покупатель не будет работать, пока не будет доступных для обработки вещей, созданных производителем (покупатель заблокируется на операции ```down(&full)```), то есть оба не будут работать до наступления какого-либо события.

Семафор *mutex* выполняет задачу **взаимного исключения** - он гарантирует, что с буфером не будут работать и производитель, и покупатель одновременно (один из них заблокируется на операции ```down(&mutex)```).

#### 3) Мьютекс
**Мьютекс (mutex)** - это облегчённый семафор, который не может быть использован как счётчик активизаций, поэтому используется только для обеспечения гарантии, что единовременно с критической областью будет работать **только один** поток.

Мьютексы могут быть использованы *только для взаимного исключения* потоков, в отличие от семафоров, которые выполняют также задачу синхронизации потоков.

Мьютекс может находиться только в одном из двух состояний: **заблокированном** и **незаблокированном**.

Существуют две операции с мьютексом:
- **Операция mutex_lock()** - блокирует мьютекс. Если мьютекс не заблокирован, то потоку разрешается войти в критическую область. Если же мьютекс уже заблокирован, то поток блокируется в ожидании разблокировки мьютекса другим потоком, который работает с критической областью.
- **Операция mutex_unlock()** - разблокирует мьютекс.

#### 4) Мониторы
**Монитор** - механизм, который предоставляет процедуры, взаимодействующие с критической областью.

Если процедуры были объявлены внутри монитора, то монитор гарантирует взаимное исключение потоков - единовременно только один поток может работать в мониторе. Если какой-нибудь поток уже работает в мониторе, то второй поток заблокируется в ожидании при попытке войти в монитор, пока первый не выйдет из монитора.

Монитор обладает одним важным отличием от остальных примитивов синхронизации: обеспечением взаимного исключения занимается сам монитор, тем самым избавляя программиста от непосредственной работы с примитивами синхронизации, что снижает количество возможных ошибок программиста. Это достигается путем неявного добавления мьютекса ко всем процедурам.

В Java можно объявлять функции как *synchronized*. Тогда Java гарантирует, что как только один поток приступает к выполнению данной функции, никакой другой поток не сможет вызвать любые другие synchronized методы этого класса.

-------

### 26) Монитор и мьютекс - это одно и тоже, или нет?
Нет, это не одно и то же. Монитор - механизм, который *неявно* оборачивает методы внутри так, что гарантирует, что единовременно только один поток сможет работать в мониторе. Это избавляет программиста от непосредственного использования мьютексов.
Мьютексы же позволят прямо контролировать поведение так, как того хочет программист, но при этом программисту приходится непосредственно работать с мьютексами и думать о дизайне функции и следить за ошибками при написании кода с использованием мьютексов, чтобы не было хаоса при неправильном их использовании.

-------

### 27) Как выбрать подходящий примитив синхронизации

Спинлок следует применять, когда есть **гарантия того, что ожидание будет недолгим** по двум причинам:
1) Недолгое простаивание стоит меньше, чем вызов планировщика и выполнение Context Switch, то есть смена потоков
2) В случае с мьютексом или семафором потоку придётся снова ждать возможности выполнения, в отличие от потока, который заблокирован на спинлоке: данный поток сможет завершить требуемые операции и потратить свой квант времени полностью.

Семафоры следует применять в ситуациях, когда необходимо **ограничить количество потоков до n штук**, которые имеют доступ к критический области одновременно, а также в ситуациях, когда необходимы атомарные действия с общими переменными-счетчиками.

Мьютексы следует применять в ситуациях, когда необходимо обеспечить гарантию того, что доступ к критической области будет иметь **единовременно только один поток**. Используется в большинстве ситуаций.

---

### 28) Когда лучше применять спинлок и что такое недолгое ожидание?
Разработчику оценить куски кода, защищенные спинлоком: вызываются ли блокирующие операции в этих областях кода? Это критично, потому что ожидание блокирующей операции может занять очень долгое время, и поток, заблокированный на спинлоке, рискует на очень долгое время занять процессор, в отличие от мьютекса, который сразу бы отдал возможность выполнения.

 Если же спинлоком защищены такие наборы команд, которые простые и быстрые, например различные O(1) операции, то тогда лучше будет использовать спинлок, так производительность будет выше, чем при использовании мьютекса.

**Вывод:** спинлоками обычно защищаются такие куски кода, которые гарантированно будут быстро выполнимы и не могут блокировать поток на долгое время в ожидании блокирующей операции.

-------

### 29) А операции с примитивами синхронизации - они вообще дорогие? Можно что-то сделать, для того чтобы их не пришлось ипользовать, или их использование было минимальным?

Дорогие или нет - зависит от ситуации. Например, использование спинлока в ситуации когда есть гарантия того, что ожидание будет недолгим - это хорошо, так как в этом случае не происходит вызова к ядру для отдавания возможности выполнения, которое повлечёт вызов планировщика, смену потоков, а также потому что при блокировке потоку придётся снова дожидаться своей очереди, пока ему выдастся квант времени, так как свой квант он уже потерял, а ведь при недолгом ожидании он мог бы сразу завершить свои задачи или отработать полный квант времени. Но если ожидание долгое, то это плохо сказывется на производительности, так как процессор не делает полезной работы  довольно долгое время, что лучше было бы отдать право выполнения другому потоку.

Самый наивный и простой способ избавиться от необходимости использования примитивов синхронизации - это не использовать общие данные вообще.

Сократить же использование примитивов можно, сделав так чтобы потоки использовали в большинстве свои данные, а не общие.