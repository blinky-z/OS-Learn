### Содержание:
- [Что такое процесс](https://github.com/blinky-z/ThreadsLearn#1-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Что такое поток?](https://github.com/blinky-z/ThreadsLearn#2-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%87%D0%B5%D0%BC-%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%B5%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%81%D0%B2%D0%BE%D0%B8%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
- [Почему нужно много потоков внутри одного процесса?](https://github.com/blinky-z/ThreadsLearn#3-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)
- [Отличие процесса от потока](https://github.com/blinky-z/ThreadsLearn#4-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%BE%D1%82-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
- [Состояния потоков](https://github.com/blinky-z/ThreadsLearn#5-%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Почему создание и уничтожение процессов дороже, чем потоков?](https://github.com/blinky-z/ThreadsLearn#6-%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%B4%D0%BE%D1%80%D0%BE%D0%B6%D0%B5-%D1%87%D0%B5%D0%BC-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2)
- [Зачем нужна многозадачность](https://github.com/blinky-z/ThreadsLearn#7-%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
- [Как происходит процесс смены потоков (context switch)?](https://github.com/blinky-z/ThreadsLearn#8-%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%BC%D0%B5%D0%BD%D1%8B-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-context-switch)
- [Реализации потоков на уровне ядра и уровне пользователя](https://github.com/blinky-z/ThreadsLearn#9-%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне пользователя](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F)
    - [Потоки на уровне ядра](https://github.com/blinky-z/ThreadsLearn#%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%BD%D0%B0-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%8F%D0%B4%D1%80%D0%B0)

### Что такое процесс
**Процесс** - это абстракция, реализованная на программном уровне - уровне операционной системы.

Процесс был придуман для организации всех данных, необходимых для работы программы. Можно сказать, что процесс - это просто контейнер, в котором находятся *ресурсы программы*.

**Элементы процесса:**
- *адресное пространство*
- *потоки*
- *открытые файлы*
- *дочерние процессы*

Просто к слову, адресное пространство - это не только пространство в оперативной памяти (начало адресов и конец), но также может
иногда использоваться и виртуальная память. Адресное пространство - это абстрактная вещь, через которую программа может получать
доступ к памяти например так: memory[0], не зная к какой памяти вообще обращается, а доступ к оперативной или виртуальной памяти
обеспечивают другие вещи.

-------

### Что такое поток
 **Поток** - это сущность, в которой выполняются процедуры программы. Поток легче, чем процесс, и создание потока стоит дешевле.
 
Потоки используют адресное пространство процесса, которому они принадлежат, поэтому потоки внутри одного процесса могут обмениваться данными и взаимодействовать с другими потоками.

**Элементы потока:**
 - *Счётчик команд*
 - *Регистры*
 - *Стек*

-------

### Почему нужно много потоков внутри одного процесса
Поддержка множества потоков внутри одного процесса нужна потому, что для работы программы обычно требуется выполнение множества задач.
Также, часто, задачам необходимо обмениваться данными, использовать общие данные или результаты других задач.
Такую возможность предоставляют потоки внутри процесса, так как они используют адресное пространство процесса, которому принадлежат.

Конечно, можно было бы создать ещё один процесс под задачу, но:
  - у процесса будет отдельное адресное пространство и данные
  - по вопросам производительности: создание и уничтожение процесса дороже, чем создание потока

-------

### Отличие процесса от потока
Процесс *описывает*  выполняющуюся программу (описывает, значит содержит необходимые ресурсы для работы программы), а сама программа же, её *процедуры выполняются в потоках*. Главное надо понимать, что программа - это не один поток.

**Программа** - это *набор взаимодейстущих между собой потоков*, и может быть, даже процессов.

Конечно, может быть 1 поток, если это какая-то совсем простая программа.
А в самых простейших операционных системах процесс имеет только единственный поток выполнения, поэтому в таких случаях немного размываются границы между потоками и процессами, т.к. 1 процесс - это 1 поток, но это так, к слову.

 **Вывод:** процесс - это всего лишь *способ сгруппировать взаимосвязанные данные, ресурсы*, а вот потоки - уже именно то, *что
распределяется и выполняется на процессоре* . А если кто-то говорит о том, что процессы сменяются и выделяется время процессам,
наверное, имеется в виду процесс с единственным потоком в простых ОСях, так как процессы сменяться не могут, сменяются и
выполняются на процессоре только потоки. Context switch тоже относится только к потокам.

-------

### Что такое счётчик команд

**Счётчик команд** - регистр процессора, который указывает, какую команду нужно выполнить следующей. Счётчик команд содержит адрес ячейки памяти, содержащей команду.

Счётчик команд - это один из наиболее важных регистров процессора, так как позволяет выполнять алгоритмы, которые являются последовательностями команд.

После выполнения текущей команды счётчик автоматически увеличивается (инкрементируется), и в регистре будет храниться следующая команда, которую необходимо выполнить.

Команда, которая выполняется в текущий момент, хранится в **регистре команд**. Однако, в завивисомсти от архитектуры, текущая выполняемая команда может храниться и в счётчике команд.

-------

### Состояния потоков
 - *Выполняемый*
 - *Готовый* (процесс не заблокирован, и может выполняться, однако, в данный момент времени на процессоре выполняется другой поток. Когда
происходит смена потоков, то новым выполняемым потоком становится только один из готовых потоков).
 - *Заблокированный* (обычно ожидает результатов завершения блокирующей операции)

### Почему создание и уничтожение процессов дороже, чем потоков
Процесс - полностью описывает программу: адресное пространство, потоки, открытые файлы, дочерние процессы, все эти таблицы данных должны инициализироваться при создании процесса. Тогда как потоки не хранят таких данных (т.к. они используют данные процесса, к которому они прикреплены), а хранит только счетчик команд, стек и регистры (поэтому потоки также называют "легкими процессами").

-------

### Что такое многозадачность
**Многозадачность** - свойство ОСи, позволяющее обеспечивать выполнение сразу нескольких задач на одном процессоре. Многозадачность может быть **параллельной** (если каждая задача выполняется на отдельном процессоре) или **псевдопараллельной** (если задачи выполняются на одном процессоре).

-------

### Для чего нужна многозадачность
Многозадачность нужна для того, чтобы на процессоре могли выполняться сразу несколько потоков.

Данная необходимость возникла потому, что крайне нежелательная пустая трата процессорного времени, то есть простаивание процессора.
Простаивание возникает тогда, когда какой-либо поток блокируется в ожидании результата блокирующей операции. Тогда, лучше отдать
процессорное время другому потоку, чтобы процессор не простаивал, таким образом повышая производительность.

Также, многозадачность позволяет запускать сразу несколько программ на компьютере.

-------

### Вытесняющая и кооперативная многозадачность
Существуют **вытесняющие** и **кооперативные** алгоритмы планирования:
 - При вытесняющем режиме работы потоки могут **прерываться принудительно** при истечении отведенного им кванта времени.
 - При невытесняющем режиме работы потоки могут **работать столько, сколько им необходимо**. Переключение контекста произойдет **только** при завершении работы потока, блокировке или при добровольном предоставлении возможности выполнения (например, функция *yield()* в Unix). При использовании кооперативной многозадачности нужно быть предельно осторожным, иначе может возникнуть ситуация, когда один поток полностью захватит процессор.

**Применение вытесняющей многозадачности:**
вытесняющая многозадачность применяется в интерактивных системах. В такой системе ни один поток не может получать больше процессорного времени, чем какой-либо другой эквивалентный ему: каждый поток должен получать справедливое процессорное время. Значит, потоки не могут сами решать, сколько им выполняться, поэтому в интерактивной среде следует применять вытесняющую многозадачность.

Вытесняющая многозадачность называется так потому, что потоки будто вытесняют друг друга, ведь каждый хочет выполняться.

**Применение кооперативной многозадачности (cooperative multitasking):**
кооперативная многозадачность применяется в системах реального времени, так как в такой среде потоки знают, что они могут запускаться только на непродолжительные отрезки времени. Также, в среде реального времени потоки запускаются только для решения определённой задачи с последующим самостоятельным блокированием, в отличие от интерактивных систем, где задачи произвольны и не преследуют цель решить конкретную задачу. Кроме того, из-за отсутствия принудительного переключения потоков, повышается производительность и эффективность работы системы, так как количество прерываний сильно сокращается. 

Кооперативная многозадачность называется так потому, что потоки должны кооперировать между собой, то есть правильно распределять время выполнения, передавая возможность работы другим потокам, чтобы происходила работа системы. Потоки не хотят выполняться, пока им не передадут возможность выполнения, все потоки терпеливо ждут своей очереди, потому что знают, что каждый выполняет свою определённую задачу, и в разные моменты времени требуется выполнение определённых задач для работы программы.

**Вывод:** кооперативная многозадачность может быть особенно на системах реального времени. Вытесняющая многозадачность подходит лучше для интерактивных систем.

-------

### Что такое Context switch
**Context switch (переключение контекста)** - это процесс прерывания работы потока с сохранением состояния потока и загрузка состояния следующего потока (который тоже был сохранен раннее), к выполнению которого приступит процессор.

Вызов Context switch инициируется *планировщиком*. Планировщик должен решить, какой поток будет выполняться следующим, и происходит context switch, который загружает состояние данного потока.
Однако, если планировщик решит, что потоки сменяться не должны и прервавшемуся потоку разрешается работать дальше, context switch может и не произойти.

-------

### Что такое планировщик задач в ОС
**Планировщик задач** - это программа (демон), на которую ложится задача выбора потока, который будет выполняться следующим. Планировщик применяется в многозадачности.

-------

### Как работает планировщик задач
**Алгоритм планирования** - алгоритм, который используется в планировщике. От алгоритма планирования зависит распределение порядка работы потоков.

**Основной принцип планирования** - предоставление каждому потоку **справедливой** доли процессорного времени. Однако, в некоторых алгоритмах планирования различные категории потоков могут получать большее процессорное время, чем потоки с низким приоритетом

Алгоритмы планирования зависят от среды выполнения:
 - *Пакетные системы*
 - *Интерактивная система*
 - *Система реального времени*

**Вызов планировщика происходит в следующих ситуациях:** 
 1) *При создании нового потока*
 2) *При завершении работы потока*
 3) *При блокировке потока в ожидании результата блокирующей операции* (операция ввода-вывода, блокировка на семафоре или мьютексе или другая
причина блокировки)
 4) *При возникновении прерывания ввода-вывода*

**Рассмотрим работу планировщика в описанных выше ситуациях:**
#### Создание нового потока
Планировщик должен решить, какому потоку позволить выполняться следующим: дочерний (только что созданный) или родительский (инициировавший создание нового потока)
#### Завершение работы потока
Когда поток завершает свою работу, необходимо выбрать следующий поток для выполнения
#### Блокировка потока
Когда поток блокируется, планировщик должен выбрать поток, который будет выполняться следующим во избежании пустой траты процессорного времени
#### Возникновение прерывания ввода-вывода
Если устройство ввода-вывода завершило свою работу и готово вернуть результат, то какой-то поток, который был заблокирован в ожидании результата данной операции, теперь может быть готов к выполнению. Планировщик должен решить, какой из заблокированных потоков или каких-либо других потоков должен продолжить свое выполнение.

-------

### Основные механизмы планирования в интерактивных системах
#### 1) Циклическое планирование
Каждому потоку назначается определенный квант времени (квант - интервал времени, в течение которого потоку позволено выполняться).
Для реализации квантов операционная система устанавливает специальный **таймер, который генерирует сигнал прерывания** по истечении
некоторого интервала времени.

Если поток к завершению своего кванта все ещё выполняется, то он прерывается **принудительно**  и происходит context switch, позволяя другому потоку поработать.

Если поток завершил свое выполнение, заблокировал или отдал возможность выполняться добровольно, то переключение контекста происходит именно в
этот момент, раньше завершения кванта времени.

Отработавший поток помещается в конец очереди, и все потоки выполняются по кругу снова и снова.

#### 2) Приоритетное планирование
В циклическом планировании все потоки равнозначны, данный же механизм позволяет ввести определенную политику для потоков, что различные потоки будут иметь различные приоритеты. Тогда следующий поток для выполнения выбирается из тех готовых потоков, которые имеют наивысший приоритет перед остальными.

Однако, здесь всплывается проблема бесконечного выполнения высокоприоритетных потоков. Существует несколько решений данной проблемы:
 1) По истечении определенного промежутка времени каждый раз снижать приоритет текущего выполняемого потока. Если это приведет к тому, что следующий в очереди готовых потоков будет иметь приоритет выше, чем текущий, то произойдет переключение контекста.
 2) Назначать каждому потоку максимальный квант времени, который он может проработать. Как только квант времени будет исчерпан, произойдет переключение контекста. Как только все потоки отработают, потокам будет снова назначен квант времени.

Приоритетное планировани бывает **статическим** и **динамическим**:
 - В статическим режиме различным задачач приоритеты присваиваются **при старте работы программы**. Данный режим проще в реализации.
 - В динамическом режиме различным задачам могут назначаться приоритеты **во время выполнения**, помимо первоначального назначения приоритета.
 Это позволяет реагировать на изменения в среде и выполнять определенные задачи незамедлительно в зависимости от ситуации.

-------

### Режим ядра и пользователя
- **Режим ядра:** позволяет иметь доступ *ко всей памяти*, *прямой доступ к аппаратному обеспечению* и выполнять любые процессорные инструкции.
Если в режиме ядра произойдет ошибка, это может привести к остановке работы всего компьютера, потребовав дальнейшеую перезагрузку, поэтому в ядре предусмотрено несколько уровней доступа и механизмов защиты.
- **Режим пользователя:** предоставляет доступ только *к определенным участкам памяти*, а *доступ к аппаратному обеспечению ограничен*.
Все потоки в операционной системе выполняются в режиме пользователя, и если им требуется доступ к аппаратному обеспечению
(ввод с клавиатуры, прочитать данные с диска и прочее) или выполнению ограниченной инструкции, они должны обратиться сперва к ядру операционной системы во избежание ошибок. Такие обращения к операционной системе называются **system call (syscall)**.
Ошибки в таком режиме не катастрофичны и всегда исправимы.

Следует понять, что системные вызовы **не переводят работу программы в режим ядра**, а только выполняют необходимые инструкции на стороне ядра и возвращают обратно требуемый результат.

-------

### Реализации потоков на уровне ядра и уровне пользователя
#### Потоки на уровне пользователя
В данной реализации потоки реализованы на пользовательском уровне, а значит, ядру ничего ни о каких потоках не известно. Ядро работает с потоками как с однопоточными процессами. Потоки запускаются поверх *системы поддержки исполнения программ* (run-time system), которая управляет потоками.
Run-time система находится внутри процесса.
Также, так как ядру ничего неизвестно о потоках и нет данных о них, процессам придется хранить *таблицу потоков* (аналогична с таблицей процессов),
чтобы отслеживать потоки, которые выполняются внутри процесса. В таблице потоков хранится такая информация о потоках, как: указатель стека, регистр,
состояние потока и прочее (все, что нужно для работы потоков, опять же аналогия с процессами).

**Достоинства:**
- Потоки могут быть реализованы на ОСях (как библиотеки), которые даже не поддерживают потоки (а только процессы).
 Но вряд ли сейчас это актуально вообще
- Переключение потоков происходит быстрее, так как нет необходимости переключения в режим ядра. Все данные уже есть на стороне пользователя:
    1) Сохранение данных в стек тоже не требуется, данные могут быть сохранены в таблицу потоков (стек находится в таблице потоков, а не в ядре)
    2) Сохранение данных и вызов планировщика - это локальные процедуры и могут быть вызваны сразу с пользовательского уровня. Как итог, переключения в режим ядра вообще не происходит.
- Система поддержки исполнения программ владеет информацией о том, чем занимаются все потоки процесса, поэтому может лучше управлять работой потоков и временем работы каждого потока. Ядро такой информацией не обладает (данная проблема может решиться использованием приоритетов, но это
универсальное решение, а в run-time система может быть какая-то другая, специфическая информация, поэтому тут выигрывают потоки на стороне пользователя)

**Недостатки:**
- При выполнении блокирующего вызова в одном потоке, блокируются все потоки данного процесса, ведь ядро думает, что работает с одним процессом, и приписывает этому процессу единое состояние выполнения: блокируется 1 поток (как думает ядро) - блокируется весь процесс со всеми потоками (как происходит на самом деле)
 Как решение проблемы могут использоваться неблокирующие системные вызовы, но нужна их поддержка. Также, может использоваться мультиплексор select.
- Не поддерживается работа аппаратного таймера с пользовательскими потоками, соответственно, не возможно будет планирование выделениия квантов
времени потокам, поэтому потокам придется вызывать функции уступания процессорного времени самостоятельно, и только тогда планировщик сможет планировать работу, иначе поток будет работать бесконечно

#### Потоки на уровне ядра
В данной реализации уже нет необходимости в таблице потоков *в каждом процессе* и нет необходимости в run-time системе. Вместо этого, аналогичная таблица потоков находится на стороне ядра, где отслеживаются *все потоки* системы.

Однако, теперь, когда нужно создать или уничтожить поток, должны производиться обращения к ядру.

Также, разница заключается в том, что планировщик в run-time системе работал только с потоками внутри *только этого процесса*, пока ядро не отдавало процессорное время другому процессу (и уже работала другая run-time система только с собственными потоками). Ядро же теперь знает о всех потоках системы и может отдавать процессорное время как потоку из одного процесса, так и потоку из другого процесса.

**Достоинства**
- Не нужно мучиться с проблемой блокирования всех потоков, в отличие от реализации потоков на пользовательском уровне. Блокируется только один поток, так как ядро теперь знает о существовании потоков

**Недостатки**
- Создание и уничтожение потоков требует более высоких затрат

-------

### что такое зелёный поток? чем он отличается от обычного потока?
**Зеленый поток** - это поток, который управляется полностью виртуальной машиной или программным обеспечением без помощи операционной системы.
Зеленые потоки выполняются в пространстве пользователя, поэтому они могут быть реализованы в тех ОСях, которые не поддерживают потоки на уровне операционной системы.

-------

### операционная система (например, linux) решила, что данный процесс должен запустится. Что это вообще означает, и какие операционная система делает действия в этом месте.

Тут происходит context switch. Он мог быть вызван данными ситуациями (возьму из пункта про context switch):
 
-------

### Создать новый процесс дорого, или дешево с точки зрения ресурсов ОС? Почему так? Как вообще создаются процессы? Откуда они изначально берутся
Создание процесса - дорого. Но вообще это зависит от ОСи. Потому что процесс должен описывать программу полностью: таблицы всех открытых файлов, потоков, адресное пространство. Все это должно инициализироваться. Однако, например, в Unix новый созданный процесс полностью копирует родительский процесс и имеет абсолютно такие же данные, тем самым они не инициализируются снова, поэтому позволяет проделать какие-либо команды перед непосредственным переходом к выполнению процедуры. Только после выполнения процедуры *exec()*  процесс инициализируется новыми данными. В Windows же, новый поток сразу инициализируется новыми данными. Данный пример показывает, что некоторые детали реализации зависят от ОСи.

Все процессы в Unix начинаются с одного стартового - процесса **init**, который создается во время запуска системы (в Windows есть аналогичный стартовый процесс - **System Idle Process**). Можно сказать, что в вершине иерархии абсолютно всех процессов в Unix стоит процесс **init** (в Windows иерархии процессов нет - все процессы равнозначны).

Создать процесс в Unix можно командой *fork()*.

-------

### Создать новый поток дорого, или дешево с точки зрения ресурсов ОС? Почему так? Кто создаёт потоки? Откуда первый поток берётся?
Создать поток дешевле, чем процесс, из-за того, что поток всего лишь содержит необходимые данные для работы процедур, а не описывает полностью программу.

Создать поток в Unix можно командой *pthread_create()*.

Первый поток, от которого могут быть образованы другие дочерние потоки, всегда инициализируется в созданном процессе и называется **main thread**.

-------

### Есть программа. Она читает из сокета. Если она будет читать из сокета в 10 потоков, она всегда будет быстрее, чем с 1 потоком?
Нет, не будет, так как перед тем как взять новые данные из сокета, нужно прочитать старые, и пока старые прочитаны не будут, поток не сможет прочитать новые, то есть, единовременно только 1 поток читает данные. Значит, разделять работу на несколько потоков нет необходимости.

-------

### Есть программа. Она считает сумму какого-то большого массива данных. Она всегда будет быстрее в 10 потоков, чем если бы в ней был 1 поток? Объясни почему так?
1) **В случае параллельной многозадачности (многоядерной среды):**
Да, будет быстрее. Можно распределить работу на 10 потоков, назначив каждому потоку вычисление определенного промежутка массива. Каждый поток посчитает свой промежуток и вернет результат, из полученных
результатов получится сумма всего массива. Поэтому параллельные вычисления (параллельная многозадачность) активно применяются в науке - ученым нужно много считать много чисел (например, умножение больших матриц).
2) **В случае псевдопараллельной многозадачности (одноядерной среды):**
Нет, распределив работу на 10 потоков, вычисление не будет быстрее, а, возможно, даже займёт даже больше времени из-за траты времени на переключение потоков (хоть оно и незначительно)

-------

### Есть процесс - музыкальный плеер. Каким образом ты слышишь постоянно музыку, но при этом работают и другие процессы
Проигрыш звука, музыки - это среда реального времени. Очередной буфер аудио или видео должен поставляться программой в жесткие сроки, чтобы не было задержек звука или видео.
Человеческое ухо очень чувствительно к задержкам воспроизвдения аудио, так что самое максимальное время, которое поток воспроизводящий аудио, может простаивать - около 5 мс.
Самое главное - плеер не воспроизводит звук, это всего лишь оболочка для удобного вопроизведения файлов - функции, проигрывающие аудио, называются **audio callback function**, и имеют больший приоритет.

Основные принципы для избежания потерь и задержек аудио:
1) Нельзя никогда блокировать поток, который воспроизводит аудио
2) Нужно при разработке или использовании алгоритма воспроизведния аудио смотреть не на среднее время выполнения (average case), а на *худшее время выполнения* алгоритма (worst case)

-------

### Что такое примитивы синхронизации, и как это вообще работает? Если бы ты писал свой язык программирования, в твоем языке могли бы появится примитивы синхронизации?
**Примитивы синхронизации** - механизмы, позволяющие обеспечить единовременно доступ только одного потока к критической области.

Примитивы синхронизации позволяют разрешать следующие ситуации:
 1) Когда несколько потоков пытаются работать с критической областью (общие файлы и данные)
 2) Когда один поток ожидает результата работы второго потока

-------

### Основные примитивы синхронизации

Примитив синхронизации должен соблюдать следующие условия:
1. Два процесса не могут одновременно находиться в своих критических областях.
2. Не должны выстраиваться никакие предположения по поводу скорости или ко-
личества центральных процессоров.
3. Никакие процессы, выполняемые за пределами своих критических областей, не 
могут блокироваться любым другим процессом.
4. Процессы не должны находиться в вечном ожидании входа в свои критические 
области.

-------

#### 1) Спинлоки
**Спинлок**  - это активное ожидание. Поток выполняет цикл, который постоянно проверяет, пока флаг (flag) не станет определённым значением, при котором потоку будет разрешено работать с критической областью.

Пример:

**Поток 1:** 
```c++
while (flag != 0); <- активное ожидание 
do_critical();
flag = 1;
do_noncritical();
```

**Поток 2:**
```c++
while (flag != 1);
do_critical();
flag = 0;
do_noncritical();
```

Таки образом, потоки взаимоисключают друг друга. Пока значение flag не станет равно 0, первый поток не начнёт работу, и также, пока значение flag не станет равно 1, второй поток не начнёт работу. При чем, при смене значения, каждый поток уже выходит из критической области.

Однако, здесь существует одна проблема, связанная с скоростью выполнения своих задач потоками.

 Предположим, что поток 2 установил значение flag в 0 и начал выполнять do_noncritical(), поток 1 выполнил свою работу и снова вернулся к циклу, но ему будет **не разрешено войти**  в работу, так как поток 2 все ещё выполняет do_noncritical(). Тогда, хоть никакой поток и не занят работой с критической областью, потоку 1 все равно не будет разрешено в критическую область, пока поток 2 не установит снова значение flag в 0, а для этого придётся дождаться выполнения работы с do_noncritical().

Это простой механизм, однако обоадает серьёзными проблемами:
1) активное ожидание - это пустая трата процессорного времени
2) он нарушает условие 3: второй поток может заблокировать первый, даже если первый выполняется вне критической области

Существует разные вариации алгоритмов (например, алгоритм Петерсора, TSL (блокировка шины памяти, которая запрещает другим потокам получить доступ к памяти), использующих данный принцип, однако все они обладают проблемой пустой траты процессорного времени.

#### 2) Семафоры
**Семафор** - специальный тип переменой, который позволяет подсчитывать количество активизаций.

Существуют две операции над семафорами - *down*  и *up*, которые являются *атомарными действиями*. Атомарность гарантирует то, что во время выполнения операции одним потоком, никакой другой поток не сможет получить доступ к семафору. Тем самым исключаются состязательные ситуации.

**Операция down:** пытается понизить значение семафора на единицу: если значение семафора равно нулю, то поток блокируется, иначе значение декрементируется и поток работает дальше.

**Операция up:** повышает значение на единицу и система разблокирует один из заблокированных на данном семафоре потоков, если таковые есть. Разблокированный поток завершает операцию down (при этом значение семафора снова становится нулевым) и продолжает работать дальше.

Существуют различные цели использования семафоров:
1) *Для синхронизации потоков* - в данном случае семафоры гарантируют наступление тех или иных конкретных событий, то есть поток не будет работать (блокируется), пока не наступило какое-то событие (пока значение семафора не стало отличным от нуля). Другой поток в таком случае должен гарантировать наступление данного события. 
2) *Для взаимного исключения* - в данном случае семафоры гарантируют, что единовременно с критической областью будет работать только один поток.

Рассмотрим задачу производителя и потребителя для большего понимания использования семафора:
```c++
semaphore mutex;
semaphore full;
semaphore empty;
ItemBuffer items;

void producer() {
    while (true) {
        Item item = create_item();
        down(&empty);
        down(&mutex);
        items.insert(item);
        up(&mutex);
        up(&full);
   } 
}

void consumer() {
    while (true) {
        down(&full);
        down(&mutex);
        Item item = items.remove();
        up(&mutex);
        up(&empty);
        handle_item(item);
   } 
} 
```

Здесь, семафоры *full* и *empty* выполняют задачу **синхронизации** - они гарантируют, что производитель не будет работать, пока не будет свободных слотов (заблокируется на операции ```down(&empty)```), а покупатель не будет работать, пока не будет доступных вещей, созданных производителем (заблокируется на операции ```up(&full)```), то есть оба не будут работать до наступления какого-либо события.

Семафор *mutex* выполняет задачу **взаимного исключения** - он гарантирует, что с буфером не будут работать и производитель, и покупатель одновременно (один из них заблокируется на операции ```down(&mutex)```).

#### 3) Мьютексы
**Мьютекс** - это облегчённый семафор, который не может быть использован как счётчик активизаций. Соответственно, он применяется в тех случаях, когда нет необходимости в подсчитывании активизаций. 
Мьютексы, в отличие от семафоров, могут быть использованы только для **взаимного исключения** потоков. 

Мьютекс может находиться только в одном из двух состояний: **заблокированном** и **незаблокированном**.

Существуют две операции с мьютексом:
- **Операция mutex_lock()** - блокирует мьютекс. Если мьютекс не заблокирован, то потоку разрешается войти в критическую область. Если же мьютекс уже заблокирован, то поток блокируется в ожидании разблокировки мьютекса другим потоком, который работает с критической областью.
- **Операция mutex_unlock()** - разблокирует мьютекс.

#### 4) Фьютексы

#### 6) Мониторы
-------

### Существует много всяких примитивов синронизации. Я - человек, который ничего об этом не знает. Расскажи мне алгоритм, как выбрать какой-то примитив синхронизации для моей задачи. Типо, если мне надо ***, и ***, то я должен выбрать *** потому, что.

Активное ожидание следует применять, когда есть гарантия того, что ожидание будет недолгим. 

-------

### А операции с примитивами синхронизации - они вообще дорогие? Можно что-то сделать, для того чтобы их не пришлось ипользовать, или их использование было минимальным?

-------

### Монитор и мьютекс - это одно и тоже, или нет?