Здесь конспектируются главы 4 и 5 - управление памятью (память, используемая процессами) и файловой системой.

## 1) В чем разница между virtual memory и virtual address space
**Virtual memory** - это память на стороннем хранилище, а не в main memory. Сторонняя память - это например remote хранилище, жёсткий диск и др. Виртуальная память позволяет расширить пространство под процессы, т.е. если какие-либо страницы памяти не могут полностью поместиться в главой памяти, то они хранятся в виртуальной памяти и подгружаются в оперативную память при необходимости (в момент погрузки этой страницы, если места все также нет, то их главной памяти выгрузится какая либо другая страницы, чтобы освободить место для подгружаемой страницы).

**Virtual address space** - это абстракция для управления памятью. Процессы, вместо того чтобы напрямую обращаться к физической памяти, работают с собственным адресным пространством, которое отражается системой на физическую память. Это позволяет защитить данные одного процесса от изменения другими процессами, а также не дать процессам испортить важные файлы, необходимые для работы самой системы.

**Например**, пусть процесс имеет адресное пространство, пронумерованное от 0 до 1024. Когда процесс обращается к адресу 560, система производит отражение этого адреса на физическую память и он превращается в физический адрес, который вычисляется так: смещение от начала физической памяти + виртуальный адрес. Например, пусть данный процесс был размещён после 4 процессов в памяти, тогда адрес превратится в: 4096 + 560 = 4656.

**Virtual Memory и Virtual Adress Space прямо связаны.** 

Дело в том, что не все данные могут поместиться в физической памяти, именно здесь и входит в работу Virtual memory, где будут храниться страницы памяти, которые не поместидись в физической памяти. У процессов все также существует свое собственное адресное пространство, но теперь система при отображении адреса проверяет также то, содержится ли необходимая страница в физической памяти или же в виртуальной памяти. Если страницы нет в физической памяти, то запускается алгоритм замещения страниц, необходимая страница загружается в физическую память, и система снова пытается отобразить виртуальный адрес на физический адрес. Без использования виртуального адресного пространства данный механизм не смог бы работать.

## 2) Файлы как абстракция управления памятью диска
**Файл** - это абстракция управления памятью диска. Процессы, вместо того, чтобы напрямую работать с физическими адресами хранилища, теперь работают с файлами. Файлы позволяют защитить данные одного пользователя операционной системы от изменения другими пользователями и предоставить более удобное управление памятью диска. Файлы можно читать и записывать, тем самым читая информационные блоки и записывая их.

## 3) Основные реализации организации файловой системы диска

### Непрерывное размещение
В такой реализации файлы представляют собой непрерывную последовательность блоков, каждый файл начинается с конца последнего записанного файла.

**Достоинства:**
- Простая реализация
- Высокая производительность, поскольку файл может быть считан единой операцией, установив позицию на начало первого блока, а кол-во блоков уже известно.

**Недостатки:**
- Постепенная фрагментация диска. При удалении файлов остаются свободные блоки фиксированных разделов, и может возникнуть такая ситуация, когда создаваемый файл может просто не поместиться никуда, и тем более не сможет расти динамически.

### Размещение с использованием связанного списка
В такой реализации файлы представляют собой связзаный список дисковых блоков. Каждый блок хранит указатель на следующий блок, или же используется таблица размещения файлов, которая хранится в памяти. Использование связанных списков позволяет хранить файлы любых размеров, так как используется не непрерывная последовательность блоков, а такое количество рандомных блоков (находящихся в разных местах диска), чтобы полностью поместить файл.

**Связанные списки блоков имеют два недостатка:**
- Сложен произвольный доступ (в обычной реализации, чтобы обратиться к блоку n, надо пройти n - 1 предшествующих ему блоков)
- Указатель на следующий блок занимает место в блоке, за счёт чего осложняется чтение целых блоков, так как информация в блоке становится не кратной двум, а именно такие размеры читаются всеми программами. Для того, чтобы прочитать целый блок, придётся брать информацию из следующего блока, что замедляет чтение.

Файлы могут легко динамически расширяться, так как требуется всего лишь добавить к последнему блоку новый блок и поставить указатель на него. 

**Использование таблицы размещения файлов**
**FAT (File Allocation Table)** позволяет решить недостатки связанных списков блоков. 
Такая таблица хранится в *оперативной памяти*, поэтому позволяет более эффективно производить произвольный доступ, так как для того, чтобы получить номер следующего блока, не требуется обращаться к *диску* (ранее указатели хранились в блоках на диске). Обращение к оперативной памяти всегда быстрее, чем к диску. Также, теперь размер блоков становится кратным 2, и чтение блоков становится эффективнее. 

Однако, такая таблица плохо масштабируется на диски больших размеров, так как с повышением кол-ва файлов таблица будет разрастаться и занимать все больше памяти. 

### i-узлы
В такой реализации каждому файлу сопоставляется одна структура данных, которая хранит атрибуты файла и все адреса блоков, из которых состоит блок. Тогда мы имеем все номера блоков сразу, и произвольный доступ становится ещё эффективнее. Также, теперь нас необходимо хранить в памяти не всю таблицу, а только те структуры, файлы которых открыты в настоящий момент. Очевидно, занимаемое пространство будет меньше чем таблица, так как размер занимаемой памяти зависит не от кол-ва файлов на диске, а от кол-ва открытых файлов, и не важно, какого размера диск, 1 гб или 1000 гб. 

Дианмическое расширение также возможно, для этого используется дополнительная запись в структуре данных, в которой находятся деревья указателей, узлы которых ведут на блоки с ещё такими же указателями, а листья таких блоков с указателями - уже блоки с информацией.

### Роль каталогов
Мы рассмотрели способы организации файлов на диске, но также требуется получить к ним доступ, т.е. найти такой файл. Для этого необходима информация о размещении файлов на диске, т.е. где находится каждый файл, т.е. его начальный блок, i-узел или адрес непрерывной последовательности в зависимости от реализации, ведь для того, чтобы прочитать  непрерывную последовательность, нам надо знать адрес начала последовательности; чтобы прочитать первый блок связанного списка, необходимо знать, где находится первый блок; чтобы знать, где находится i-узел файла, с помощью которого мы и получим доступ к файлу, нам также необходимо знать, где находится i-узел.

Одна из возможностей хранения таких данных - это использовать записи каталогов. Для того, чтобы найти файл, надо найти соответствующкю ему запись каталога на диске, в которой и будет храниться информация о файлах.

**Каталог** - это тоже файл, который не содержит информации, как блоки файлов, а только записи о файлах.

Сама же запись каталога легко находится с помощью указанного пользователем пути файла, при чем для нахождения местоположения блока каталога также используется структура данных для данных о каталоге, например i-узел. Поиск каталога начинается с корнвого каталога или же с рабочего каталога в зависимости от указанного пути (абсолютный или относительный пути). 

### Процесс считывания файла на диске на примере Unix
1. Сначала файловая система обращается к фиксированному месту на диске, где хранится i-узел корневого каталога
2. По имени указанного следующего каталога файловая система ищет в i-узле корневого каталога номера каталога с таким именем и, преобразовывая номер i-узла в адрес на диске, считывает i-узел каталога
3. Пункт 2 повторяется далее, пока не останется каталогов для открывания
4. Когда был достигнут последний каталог, в котором и находится требуемый файл, файловая система достает номер i-узла файла из i-узла каталога, преобразовывает номер i- файла в адрес на диске, считывает i-узел файла, в котором и находятся адреса всех блоков файла и файл может быть прочитан

Существуют различные оптимизации этих действий - например, размещение i-узлов и блоков файла как можно ближе друг к другу, чтобы головке диска не пришлось перемещаться далеко, а также используется кэш, находящийся в оперативной памяти, из которого могут быть считаны блоки без обращения к диску.
