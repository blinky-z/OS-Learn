## Condition Variable 

### Работа wait:
 Для начала приведем семантику работы `wait(lock, Predicate)`, в котором используется предикат:
```
while (!pred()) {
wait(lock); <- здесь вызывается обычный wait(lock) без предиката
}
```
**Тогда можем сделать следующие выводы:** 
 1) Если тред дошел до строчки с `wait(lock, Predicate)` в первый раз, то вызов wait проверяет предикат (без получения оповещения):
- если он *true*, то тред продолжает работу
- если он *false*, то тред вызывает wait(lock), который атомарно разблокирует мьютекс и помещает тред в заблокированное состояние в ожидании оповещения, то есть condition variable начинает ожидать оповещения

 Это важный момент - Тред не ждет получения оповещения в самый первый вызов wait(lock, Predicate), так как возможен случай,
 когда оповещение могло просто потеряться, но предикат был изменён.

 Теперь, если condition variable находится в состоянии ожидания оповещений (то есть проверка предиката была неуспешной и тред заблокирован) и получает оповещение:
 1) Тред *атомарно* разблокируется и захватывает мьютекс
 2) Проверяется предикат:
 - Если предикат *true*: тред продолжает работу (при этом, мьютекс остаётся заблокированным) 
  - Если предикат *false*: атомарно разблоирует мьютекс и помещает тред в заблокированное состояние

Как пример, расммотрим работу двух функций - *receiver* и *sender*:

```
void waitingForWork(){ <- receiver
    std::cout << "Waiting " << std::endl;
    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck, []{ return dataReady; });
    std::cout << "Running " << std::endl;
}

void setDataReady(){ <- sender
    {
        std::lock_guard<std::mutex> lck(mutex_);
        dataReady = true;
    }
    std::cout << "Data prepared" << std::endl;
    condVar.notify_one();
}
```

 Рассмотрим 2 ситуации: если *первый тред захватил лок первым*, и если *второй тред захватил лок первым*

 **Receiver захватил лок первый:**

 Тогда второй тред блокируется в ожидании разблокировки мьютекса
 1) Первый тред, захватив лок, продолжает работу и доходит до строчки с wait
 2) Wait сразу, без ожидания оповещений, проверяет предикат, видит, что предикат равен false (так как второй тред в это время был заблокирован и не мог изменяться), атомарно разблокирует мьютекс и тред блокируется в ожидании оповещений на condVar
 3) Второй поток дождался освобождения мьютекса, тред разблокируется и предиката устанавливается в значение true
 4) Второй поток разблокирует мьютекс и продолжает работу, далее посылая оповещение командой notify_one()
 5) Первый тред получает оповещение и проверяет предикат, видит что предикат равен true, и тред продолжает работу

 **Sender захватил лок первый:**

 Тогда первый тред блокируется в ожидании разблокировки мьютекса
 1) Второй тред устанавливает значение предиката в true и разблокирует мьютекс

    Здесь возможны 2 ситуации:
        1) Первый тред может продолжить работу в этот же момент, проверяет, что предикает равен true и продолжает работу
        2) Первый тред не продолжает работу в этот же момент, тогда второй тред продолжает работу и посылает оповещение первому потоку. Первый поток не отслеживает оповещение, а сразу проверяет что предикат равен true и продолжает работу.

### Зачем нужен предикат
 Если не использовать предикат, то возможна ситуация, когда сигнал был послан до того, как поток начал ожидание сигнала, и сигнал может потеряться (**lost wakeup** ), а также возможна ситуация, когда произошло ложное оповещение (spurious wakeup), и тред был разблокирован, однако на самом деле ожиданиемого ивента не происходило и программа будет работать неправильно.
 Поэтому мы заручаемся поддержкой не только сигналов, но и памяти. По состояния памяти (т.е. переменной) мы может
 гарантировать правильное происхождение ивентов


### Почему нужно использовать мьютекс в sender потоке? Что, если сделать предикат атомарной переменной?
 Допустим, что код потоков будет таким:
```
 void waitingForWork(){
    std::cout << "Waiting " << std::endl;
    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck, []{ return dataReady.load(); });
    std::cout << "Running " << std::endl;
 }

 void setDataReady(){ <- sender
     dataReady.store(true);
     std::cout << "Data prepared" << std::endl;
     condVar.notify_one();
 }
```

 Тогда, еще раз рассмотрим работу двух потоков:
 1) Если первый поток доходит до строчки с wait(), он проверяет первый раз:
      1) Если второй поток успел положить значение true в предикат до того, как первый поток начал проверять его, то
 первый поток убеждается в происхождении ивента и успешно продолжает работу, все проходит нормально
      2) Если первый поток видит значение false, то тред вызывает wait() и поток блокируется. НО, именно между моментом
 проверки предиката и блокировки треда в ожидании оповещений появляется временное окно, т.е. эти действия не происходят
 атомарно. Именно в этот прмомежуток времени мог произойти context switch и второй тред отправил сигнал до того, как
 возможность выполнения передалась обартно к первому потоку, чтобы он смог вызвать wait() и начать ожидать оповещения.

 Итог: сигнал, посланный вторым потоком (sender) теряется, первый поток (receiver) больше никогда не получит оповещение,
 а значит, первый поток блокируется навсегда. Такая ситуация известна как Deadlock.
 Даннная проблема решается применением мьютекса во втором треде. Если первый поток захватил лок, то второй поток не
 может работать с предикатом и посылать оповещения. Первый поток увидит значение false, пройдет какой-то промежуток
 времени, но во время него второй поток не сможет получить доступ к работе над предикатом, так как он заблокируется на
 мьютексе, далее первый поток атомарно разблокирует мьютекс и входит  в заблокированное состояние в ожидании оповещения.
 Только после того, как вызов wait() разблокировал мьютекс, второй сделает работу и пошлет оповещение

 **Без использования мьютекса вторым потоком могла возникнуть такая ситуация:**
 ```
     Thread 1                         Thread 2

     unique_lock
     while (!condition)
     <временное окно,
     происходит context switch>
                                      condition = true
                                      condVar.notify_one()

     condVar.wait()
 ```

 **Почему нужно использовать mutex в вызове wait()?**
 Для избежания race condition.
 Важная особенность wait заключается в том, что он атомарно разблокирует мьютекс и помещает тред в
 заблокированное состояние. Если бы данная операция не была атомарной, то между моментом разблокировки мьютекса
 и началом ожидания оповещеня сигнал мог послаться другим тредом и потеряться, так как первый тред не успел
 войти в состояние ожидания сигнала. Как итог, происходит deadlock
 То есть, передавая мьютекс как аргумент, мы исключаем данную ситуацию.
 Кроме того, команда wait() не только атомарно разблокирует мьютекс и помещает тред в заблокированное состояние, но
 также, когда произойдет wakeup, то есть придет сигнал, атомарно разблокирует тред и повторно блокирует мьютекс.
 Дело в том, что wakeup мог быть ложным (spurious wakeup), и второй тред еще даже не приступал к работе, или же еще не
 успел послать настоящий сигнал.
 Если бы разблокировка треда и повторная блокировка мьютекса не были неделимыми действиями, то второй тред мог вступить
 в работу и послать сигнал, который потеряется
 Если бы повторной блокировки мьютекса, переданного как аргумент, не было вообще, то второй тред смог бы изменять
 состояние памяти в то время, как память проверяется первым потоком, и возник бы race condition. Более того, не
 используя повторную блокировку мьютекса, сигнал мог вообще потеряться и произошел бы deadlock.

 **Важно различать следующие моменты:**
 Мы используем мьютекс в sender треде, так как не хотим, чтобы между моментом проверки предиката и вызовом wait()
 произошло послание сигнала другим тредом
 Вызов wait() производит операции разблокировки мьютекса и помещения тред в заблокированное состояние в ожидании сигнала
атомарно - это исключает другую ситуацию, когда, даже если второй тред был защищен локом, но после разблокировки мьютекса,
 если бы произошел context switch, мог послать сигнал, который потерялся бы


 **predicate** - нам нужен предикат, так как сигналы могут теряться, поэтому нам нужна
 дополнительная гарантия в виде памяти (сейчас мы говорим об аппаратных вещах, сигналы могут теряться, тогда помогает
 отслеживание памяти)
 с помощью отслеживания состояния памяти мы можем исключить lost wakeup и spurious wakeup

 **spurious wakeup** - ложное пробуждение condition variable, то есть когда сигнала от треда, который должен был послать
 оповещение, на самом деле не было

 **lost wakeup** - ситуация, когда сигнал теряется, то есть оповещение произошло тогда, когда сигнал никто не ожидал
 То есть вызов notify() произошел до вызова notify()