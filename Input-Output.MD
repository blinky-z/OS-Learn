Здесь конспектируется глава 5 - Ввод и вывод информации

## 1) Типы устройств ввода-вывода
Устройства ввода-вывода можно разделить на 2 категории:
 - Блочные устройства
 - Символьные

**Блочные** устройства ввода-вывода хранят информацию в виде блоков фиксированной длины. Важным свойством таких устройств является то, что к ним можно применять операцию позиционирования и считывать или записывать каждый блок независимо от других (произольный доступ). Все блоки адресуются. Например: жесткий диск, магнитные ленты, флешки.

**Символьные** устройства ввода-вывода принимают или выдают поток символов, а не блоки. К такой инфомрации невозможно применять операции позиционирования и произвольный доступ невозможен, так как данные не адресуются. Например: принтер, мышь (в качестве устройства указателя).

Устройство обычно разделяется на 2 части -  само устройство и контроллер устройства. Контроллер находится на системной плате и в него вставляется кабель от самого устройства. Благодаря тому, что определенные группы устройств созданы по принятым стандартам, 1 контроллер на мат. плате может обслуживать множество устройств.

Задача **контроллера** состоит в том, чтобы выполнять принимаемые от операционной системы команды на аппаратном уровне. Также, контроллер - это интерфейс устройства. Операционные системы видят только контроллеры устройств, но не сами устройства, и имеют общий интерфейс под все устройства. Согласно стандарту все устройства должны реализовать необходимый интерфейс, чтобы контроллер мог исполнять требуемые команды операционной системы.

Поэтому, для связи с интерфейсом необходим также **драйвер устройства**. Она позволяет операционной системе производить общение с интерфейсом устройства.

**Прерывание** — это событие, при наступлении которого процессор должен приостановить выполнение текущего процесса, сохранить его состояние и начать выполнять другой процесс, называемый обработчиком прерывания (interrupt handler). После завершения обработки прерывания состояние предыдущего процесса должно быть восстановлено и работа должна продолжиться с той команды, где она остановилась.

Однако, это не всегда так. Прерывания, которые гаранитруют, что процесс продолжит свою работу так, как будто и не было прерывания, называются **точными прерываниями**, а прерывания, которые не гарантируют этого - называют **неточными**. 
Точным прерыванием является такое, что все команды, предшествующие команде, которая была прервана, были полностью выполнены, а команды, следующие за прерванной - еще не были выполнены, при это известно состояние выполнения прерванной команды (если это была команда, вызвавшая исключение, то счетчик команд не будет увеличен, и в нем будет храниться адрес этой команды, в последствии будет вызван обработчик исключения. Если же команда не вызывала исключения, то эта команда будет завершенной и счетчик команд будет указывать на следующую команду).
Неточные прерывания очень усложняют разработку систем, так как требуется отслеживать, в каком состоянии находились все команды в конвеере команд, и требуется обработка большей информацией при возникновении прерывания.

**Общение процессора с контроллером** происходит через регистры контроллера. Есть 2 способа общения с ними:
1) Формируется пространство портов ввода-вывода, так пространства памяти и портов являются отдельными адресными пространствами. 
Например:
IN R0,4 - данная команда читает порт с адресом 4 и помещает в регистр процессора R0
и
MOV R0,4 - данная же команда, хоть адрес один и тот же, читает адрес слова 4 памяти и помещает в регистр процессора R0
2) Всё адреса портов отображаются на оперативную память
3) Гибридный вариант - адреса буферов контроллеров находятся в памяти, а адреса портов ввода-вывода находятся в отпднлтос пространстве портов ввода-вывода

## 2) Процесс общения процессора и устройства ввода-вывода 
Как только процессору необходимо прочитать слово из памяти или из порта ввода-вывода на контроллере, процессор выставляет адрес на адресной линии шины, а затем выставляет сигнал READ на линии управления шины. 
 Затем, на сигнальной линии шины, указывается, какое именно пространство нужно (память, которое является одним адресным пространством, или же адресное пространство портов ввода-вывода), и запрос обработает разное устройство в зависимости от этого - память или само устройство. 
 Если используется только адресное пространство памяти, то каждое устройство сравнивает адрес на адресной линии шины со своим диапазоном обслуживаемых этим устройством адресов. Если адрес попадает в диапазон адресов памяти, то запрос обслужит память, если адрес попадает в диапазон адресов контроллера, то устройство обслужит запрос. Поскольку адресов, выделенных одновременно и памяти, и устройству, не бывает, то недоразумений не возникает. 

**Достоинства и недостатки отображения на память:**
- Если для обращения напрямую к пространству портов ввода-вывода требуются специальные вставки кода на ассемблере, что влечёт дополнительные расходы, то обращение к памяти может быть написано полностью на C или C++.
- Отсутствует необходимость механизма защиты осуществления ввода вывода со стороны пользовательских процессов. Достаточно отделить пространство регистров управления контроллеров от виртуального пространства пользователя. 
- Любая команда, которая работает с адресом памяти, может работать и с регистрации управления контроллера, то есть не требуются специальные команды. Например, команда TEST, которая проверяет слово памяти на равенство нулю (использовалась в алгоритме спинлока, мьютекса), может быть использована и с регистром управления контроллера на проверку  занятости устройства. Если бы не было отображения на пространство памяти, то пришлось бы сначала считать регистр контроллера в процессор, и только потом проверить его.

**Недостатки данного метода:**
- Кэширование значений регистров контроллера. Необходима возможность выборочного отключения Кэширование, так как Кэширование значений регистров приведёт к тому, что при обращении к регистру контроллера будет браться старое значение из кэша без обращения к устройству, и будет невозможно отследить, освободилось ли устройство. 
- Каждому устройству придётся проверять адрес на шине со своим диапазоном обслуживаемых адресов, чтобы определить, какое устройство обслуживает текущую команду. 

## 3) DMA
Но просто придания адресов регистрам контроллеров недостаточно, так как требуется ещё и обращаться к контроллерам устройств. Процессор может запрашивать данные в цикле с контроллера побайтно с буфера контроллера напрямую через шину или же использоваться DMA - Direct Memory Access. 

Рассмотрим, как происходит чтение данных с диска **без использования DMA**:

Процессор выставляет на шине адрес и команду READ, независимо от того, используется ли отображение портов на память или нет, диск обслужит эту команду. Контроллер диска считает блок и сохранит в своём буффере, инициирует прерывание, и процессор обслужит это прерывание, считав с буфера (адрес которого также имеется) в цикле побайтно данные и сохранять их в оперативной памяти. 

**С использованием DMA:**

Сначала процессор задаёт регистры DMA контроллера, заполняя его необходимыми параметрами, которые указывают что и куда передаваться.
Далее DMA контроллер вычтавляет на шине также, как и ранее процессор, запрос на чтение, который обслужит контроллер диска. Но теперь контроллеру диска указан адрес, куда вести запись данных, и он запишет их в оперативную память, а не в свой внутренний буфер. Когда запись завершится, контроллер диска посылает сигнал DMA контроллеру, сообщая, что запись завершена. Если ещё были считан не все данные, DMA контроллер повторно посылает запрос на чтение, устанавливая другой адрес памяти (этот адрес памяти = старый адрес памяти + приращение читаемых за раз байтов, чтобы данные были заполнены последовательно), куда необходимо записать данные. Как только будут считаны все данные, DMA контроллер инициирует прерывание, и процессору уже не придётся читать и записывать данные из буфера контроллера так как все данные уже были записаны в память. 

DMA позволяет освободить процессор от работы считывания и записи данных, так как для обращения к буферу контроллера пришлось бы каждый раз использовать и занимать шину, вместо всего 1 вызова использования шины для передачи команды DMA контроллеру. 

Но DMA имеет серьёзный недостаток: из-за того, чтобы данные записываются сразу в оперативную память, а не в внутренний буфер контроллера диска, то контроллеру диска приходится ожидать готовности шины, так как в какой-то момент шина может обслуживать другое устройство, например, та же память. 

Кроме того, центральный процессор работает намного быстрее чем DMA контроллер, и зачем заставлять ждать быстрый процессоре окончания работы медленного DMA контроллера. 
