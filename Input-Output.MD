Здесь конспектируется глава 5 - Ввод и вывод информации

## 1) Типы устройств ввода-вывода
Устройства ввода-вывода можно разделить на 2 категории:
 - Блочные устройства
 - Символьные

**Блочные** устройства ввода-вывода хранят информацию в виде блоков фиксированной длины. Важным свойством таких устройств является то, что к ним можно применять операцию позиционирования и считывать или записывать каждый блок независимо от других (произольный доступ). Все блоки адресуются. Например: жесткий диск, магнитные ленты, флешки.

**Символьные** устройства ввода-вывода принимают или выдают поток символов, а не блоки. К такой инфомрации невозможно применять операции позиционирования и произвольный доступ невозможен, так как данные не адресуются. Например: принтер, мышь (в качестве устройства указателя).

Устройство обычно разделяется на 2 части -  само устройство и контроллер устройства. Контроллер находится на системной плате и в него вставляется кабель от самого устройства. Благодаря тому, что определенные группы устройств созданы по принятым стандартам, 1 контроллер на мат. плате может обслуживать множество устройств.

Задача **контроллера** состоит в том, чтобы выполнять принимаемые от операционной системы команды на аппаратном уровне. Также, контроллер - это интерфейс устройства. Операционные системы видят только контроллеры устройств, но не сами устройства, и имеют общий интерфейс под все устройства. Согласно стандарту все устройства должны реализовать необходимый интерфейс, чтобы контроллер мог исполнять требуемые команды операционной системы.

Поэтому, для связи с интерфейсом необходим также **драйвер устройства**. Она позволяет операционной системе производить общение с интерфейсом устройства.

**Прерывание** — это событие, при наступлении которого процессор должен приостановить выполнение текущего процесса, сохранить его состояние и начать выполнять другой процесс, называемый обработчиком прерывания (interrupt handler). После завершения обработки прерывания состояние предыдущего процесса должно быть восстановлено и работа должна продолжиться с той команды, где она остановилась.

Однако, это не всегда так. Прерывания, которые гаранитруют, что процесс продолжит свою работу так, как будто и не было прерывания, называются **точными прерываниями**, а прерывания, которые не гарантируют этого - называют **неточными**. 
Точным прерыванием является такое, что все команды, предшествующие команде, которая была прервана, были полностью выполнены, а команды, следующие за прерванной - еще не были выполнены, при это известно состояние выполнения прерванной команды (если это была команда, вызвавшая исключение, то счетчик команд не будет увеличен, и в нем будет храниться адрес этой команды, в последствии будет вызван обработчик исключения. Если же команда не вызывала исключения, то эта команда будет завершенной и счетчик команд будет указывать на следующую команду).
Неточные прерывания очень усложняют разработку систем, так как требуется отслеживать, в каком состоянии находились все команды в конвеере команд, и требуется обработка большей информацией при возникновении прерывания.

**Общение процессора с контроллером** происходит через регистры контроллера. Есть 2 способа общения с ними:
1) Формируется пространство портов ввода-вывода, так пространства памяти и портов являются отдельными адресными пространствами. 
Например:
IN R0,4 - данная команда читает порт с адресом 4 и помещает в регистр процессора R0
и
MOV R0,4 - данная же команда, хоть адрес один и тот же, читает адрес слова 4 памяти и помещает в регистр процессора R0
2) Всё адреса портов отображаются на оперативную память
3) Гибридный вариант - адреса буферов контроллеров находятся в памяти, а адреса портов ввода-вывода находятся в отпднлтос пространстве портов ввода-вывода

## 2) Процесс общения процессора и устройства ввода-вывода 
Как только процессору необходимо прочитать слово из памяти или из порта ввода-вывода на контроллере, процессор выставляет адрес на адресной линии шины, а затем выставляет сигнал READ на линии управления шины. 
 Затем, на сигнальной линии шины, указывается, какое именно пространство нужно (память, которое является одним адресным пространством, или же адресное пространство портов ввода-вывода), и запрос обработает разное устройство в зависимости от этого - память или само устройство. 
 Если используется только адресное пространство памяти, то каждое устройство сравнивает адрес на адресной линии шины со своим диапазоном обслуживаемых этим устройством адресов. Если адрес попадает в диапазон адресов памяти, то запрос обслужит память, если адрес попадает в диапазон адресов контроллера, то устройство обслужит запрос. 

